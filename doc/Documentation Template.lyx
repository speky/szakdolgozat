#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass book
\begin_preamble
% Using a custom title page, \title required
\title{}

% PDF Generation settings
\hypersetup{
    pdfstartview={FitH},
    linkcolor=black,
    citecolor=black,
    filecolor=blue,
    urlcolor=blue,
    linktoc=all
}

% Remove page numbering from the TOC
\addtocontents{toc}{
 \protect \thispagestyle{empty}
}

% Java code display
\usepackage{marvosym}
\newcommand{\hlstd}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\hlnum}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\hlesc}[1]{\textcolor[rgb]{0.64,0.08,0.08}{#1}}
\newcommand{\hlstr}[1]{\textcolor[rgb]{0.64,0.08,0.08}{#1}}
\newcommand{\hlpps}[1]{\textcolor[rgb]{0,0,1}{#1}}
\newcommand{\hlslc}[1]{\textcolor[rgb]{0,0.5,0}{#1}}
\newcommand{\hlcom}[1]{\textcolor[rgb]{0,0.5,0}{#1}}
\newcommand{\hlppc}[1]{\textcolor[rgb]{0,0,1}{#1}}
\newcommand{\hlopt}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\hllin}[1]{\textcolor[rgb]{0.17,0.57,0.69}{#1}}
\newcommand{\hlkwa}[1]{\textcolor[rgb]{0,0,1}{#1}}
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0,0,1}{#1}}
\newcommand{\hlkwc}[1]{\textcolor[rgb]{0.17,0.57,0.69}{#1}}
\newcommand{\hlkwd}[1]{\textcolor[rgb]{0,0,0}{#1}}
\definecolor{bgcolor}{rgb}{1,1,1}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language magyar
\language_package default
\inputencoding auto
\fontencoding global
\font_roman times
\font_sans helvet
\font_typewriter courier
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format pdf2
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing onehalf
\use_hyperref true
\pdf_title "Drive Testing szakdolgozat"
\pdf_author "Specker Zsolt"
\pdf_bookmarks false
\pdf_bookmarksnumbered true
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 4
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3.5cm
\topmargin 2.5cm
\rightmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation skip
\defskip smallskip
\quotes_language swedish
\papercolumns 1
\papersides 2
\paperpagestyle plain
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Kedves dokumentum felhasználó! Ezt a sablon dokumentumot az ELTE IKs szakdolgoza
t-dokumentációd megírásának megkönnyítéséért adom.
 Bárki felhasználhatja, átalakíthatja szabadon.
 A dokumentum elkészítéséhez használd a 
\begin_inset Quotes sld
\end_inset

szemecskés
\begin_inset Quotes srd
\end_inset

 ikont (Nézet, Ctrl+R).
 Ajánlott fordítási formátum: pdflatex.
\end_layout

\begin_layout Plain Layout
Az alábbiakban írok pár megjegyzést a munkád segítéséhez!
\end_layout

\begin_layout Itemize
Ajánlott átnézni a Dokumentum -> Beállítások...
 menüpontot a dokumentum szinte bármely tulajdonságának állításához, pl:
\end_layout

\begin_deeper
\begin_layout Itemize
Egy/kétoldalasság megváltoztatása: Dokumentum -> Beállítások...
 -> Oldal formátum -> Kétoldalas dokumentum
\end_layout

\end_deeper
\begin_layout Itemize
Hivatkozások hozzáadása:
\end_layout

\begin_deeper
\begin_layout Itemize
A hivatkozás céljánál Beszúrás -> Címke...
\end_layout

\begin_layout Itemize
A hivatkozás helyén Beszúrás -> Kereszthivatkozás...
 (formátumként kiválasztani a hivatkozás szövegstílusát is)
\end_layout

\end_deeper
\begin_layout Itemize
Ábrák ajánlott hozzáadása:
\end_layout

\begin_deeper
\begin_layout Itemize
Beszúrás -> Úsztatás -> Ábra
\end_layout

\begin_layout Itemize
A keret felső részére a kép beszúrása
\end_layout

\begin_layout Itemize
A keret-beli alsó keretbe az ábra nevének begépelése
\end_layout

\end_deeper
\begin_layout Itemize
Vektorgrafikus képek (pl UML modellek) optimális hozzáadása:
\end_layout

\begin_deeper
\begin_layout Itemize
Nyomtasd ki a programból a képet egy PDF nyomtatóval
\end_layout

\begin_layout Itemize
Konvertáld a képet PDF-ből EPS-re egy internetes szolgáltatás segítségével
 (ha lehet, ASCII és level 3-as, beágyazott betűtipusú formátumba)
\end_layout

\begin_layout Itemize
Beszúrás -> Képek
\end_layout

\begin_layout Itemize
Állíts be vágást a fehér részek eltüntetéséhez, 100% sorszélességet az oldalhoz
 állításhoz
\end_layout

\end_deeper
\begin_layout Itemize
Index kitöltése: Ha látsz egy szót amit az indexhez akarsz adni, Beszúrás
 -> Tárgyszó
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% Document front matter settings
\end_layout

\begin_layout Plain Layout


\backslash
frontmatter              % Starts front matterC/C+
\end_layout

\begin_layout Plain Layout


\backslash
pagestyle{empty}         % Removes page numbering (this needs to be reset
 in main matter)
\end_layout

\begin_layout Plain Layout


\backslash
begin{titlepage}         % Starts the custom title page
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle" tabularwidth="100col%">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<row interlinespace="2mm">
<cell multirow="3" alignment="center" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\begin_inset Graphics
	filename ELTE_logo.eps
	lyxscale 15
	width 3.5cm

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row interlinespace="2mm">
<cell multirow="4" alignment="center" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series bold
EÖTVÖS LORÁND TUDOMÁNYEGYETEM
\end_layout

\end_inset
</cell>
</row>
<row interlinespace="2mm">
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series bold
INFORMATIKAI KAR
\end_layout

\end_inset
</cell>
</row>
<row bottomspace="3mm" interlinespace="2mm">
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series bold
Programozáselmélet és Szoftvertechnológiai Tanszék
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.2mm"

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
\size largest
Drive testing Androiddal
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace 6em
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle" tabularwidth="100col%">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size large
Sike Sándor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size large
Specker Zsolt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size large
ELTE IK Programozáselmélet és
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size large
ELTE IK Programtervező
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size large
Szoftvertechnológiai Tanszék
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size large
Informatikus BSc
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size large
Simonyi Tibor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size large
Ericsson Magyarország Kft.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\align center

\size large
Budapest, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
the
\backslash
year
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Ends the custom title page
\end_layout

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Document main matter start
\end_layout

\begin_layout Plain Layout


\backslash
mainmatter
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Resets the empty front matter page style to plain
\end_layout

\begin_layout Plain Layout

% Change this if an other style's prefered
\end_layout

\begin_layout Plain Layout


\backslash
pagestyle{plain}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Bevezetés
\end_layout

\begin_layout Section
Probléma leírása
\end_layout

\begin_layout Standard
A Drive testing egyfajta mérési módszere és értékelése a mobiltelefon hálózatok
 teljesítményének, kapacitásának, lefedettségének és minőségének.
 Ez a teszt fontos szerepet kap a telefonhálózatokat üzemeltető cégek -
 operátorok - hálózat tervezési, üzemeltetési stratégiáiban és nem utolsó
 sorban a hálózati hibák felderítésében.
 A drive test tipikusan az alábbi adatokat gyűjti össze a hálózatról:
\end_layout

\begin_layout Itemize
Jel intenzitás, erősség
\end_layout

\begin_layout Itemize
Adat fel- és letöltési sebesség
\end_layout

\begin_layout Itemize
Elutasított és blokkolt hívások
\end_layout

\begin_layout Itemize
Handover információk (ez egyes tornyok, cellák közötti váltás)
\end_layout

\begin_layout Itemize
Szomszédos cella információk
\end_layout

\begin_layout Standard
\noindent
\begin_inset Wrap figure
lines 0
placement r
overhang 0in
width "40text%"
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Drive-Test-System.jpg
	scale 90

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption

\begin_layout Plain Layout

\size small
Egy Drive Test felszerelés
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
A manapság használt megoldások nagyon költségesek a drága eszközök és szakembere
k miatt.
 A mérés során a tesztelő - aki általában egy mérnök - egy speciálisan felszerel
t autóval kivonul a megadott területre, ahol a tesztet el kell végeznie,
 majd bekonfigurálja az eszközöket a méréshez.
 Egy egyszerűbb felszerelés látható a jobb oldali képen.
 A mérés típusától függően lehet, hogy bonyolultabb és költségesebb eszközökre,
 felszerelésekre van szükség.
 Az autóval végigjárja a kijelölt útvonalat - akár többször is - miközben
 a mérési eredményeket rögzíti a számítógép egy speciálisan erre a célra
 fejlesztett szoftver segítségével.
 A mérés végeztével kiértékeli az eredményeket a program segítségével.
 Látható, hogy sok költséges, speciális eszközre van szükség a mérések elvégzésé
hez.
 
\end_layout

\begin_layout Section
Szakdolgozat célja
\end_layout

\begin_layout Standard
A szakdolgozatom célja egy 
\begin_inset Quotes sld
\end_inset

Drive testing" alkalmazás megvalósítása, egy kis költségvetésű Android operációs
 rendszerű mobilkészülék segítségével.
 Nagy előnye ennek a megoldásnak a meglévő technológiával szemben, hogy
 a teszt elvégzéséhez elég egy mobiltelefon készülék és nem kell drága felszerel
ést és mérnököt alkalmazni.
 Az Android platform lehetőséget nyújt arra, hogy az alkalmazás információkat
 gyűjtsön a telefonról, valamint a mobilhálózatról.
 Ezen információk segítségével egy olyan program készíthető, amely képes
 részben vagy teljesen kiváltani a jelenleg használt technikát.
 Segítséget nyújt a telefonhálózat problémáinak felderítésében és a fejlesztendő
 területek feltérképezésében.
 
\end_layout

\begin_layout Standard
Az Android platformot választottam, mivel széles körben elérhető és a [Wikipedia
] adatai szerint ezt használják a legtöbben a világon.
 Így akár a felhasználók által gyűjtött teszt adatokat is felhasználhatják
 a telefon szolgáltatók, operátorok, mivel a program használata egyszerű,
 nem igényel szaktudást.
 Csak az adatok értelmezéséhez, feldolgozásához kell szakember.
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "60col%"
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename globalDataTraffic.jpg
	lyxscale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Mobil adatforgalom 2012-2017
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A szakdolgozatom leginkább a mobil adathívások tesztelésével és elemzésével
 foglalkozik, mivel a jövőben - 4G-s hálózatok esetén is - ez a terület
 különösen fontos szerepet fog játszani a mobilkommunikációban.
 Kimutatások szerint egyre növekszik a mobilhálózatok adatforgalma és 2017-re
 elérheti a havi 11,2 exabyte-nyi mennyiséget.
 A mobilkészülékek és hálózatok fejlődésével teret hódítanak a különféle
 szolgáltatások, mint a videó telefonálás, melyek növelik az adatforgalmat
 és szükségessé teszik a gyors és megbízható adatszolgáltatást.
 A felhasználók gyakrabban használják ezeket a szolgáltatásokat, mint a
 hagyományos hanghívást.
 Így a szolgáltatóknak is alkalmazkodniuk kell a megváltozott igényekhez,
 biztosítaniuk kell a nagyobb lefedettséget és megbízható, gyors adatátvitelt.
 
\end_layout

\begin_layout Chapter
Szükséges ismeretek
\end_layout

\begin_layout Section
Mobilhálózatok bemutatása
\end_layout

\begin_layout Subsubsection*

\series bold
Mobilhálózatok kialakulása
\end_layout

\begin_layout Standard
Már a második világháborúban képesek voltak rádiótelefonos kapcsolatot kiépíteni
 katonai használatra.
 Kézi rádió adó-vevők már az 1940-es évektől elérhetőek voltak, pár telefon
 társaságnak volt gépkocsiban is használható mobil telefon készüléke.
 A korai készülékek testesek voltak és sok áramot fogyasztottak, a hálózat
 pedig csak néhány szimultán beszélgetést tudott csak kiszolgálni.
 
\begin_inset Wrap figure
lines 0
placement o
overhang 0col%
width "50col%"
status collapsed

\begin_layout Plain Layout
\noindent
\align right
\begin_inset Graphics
	filename 621px-Mobile_radio_telephone.jpg
	scale 50

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Első mobil telefonok egyike
\end_layout

\end_inset


\end_layout

\end_inset

Az egyesült államokbeli Bell laboratórium mérnökei olyan rendszeren dolgoztak,
 ami képessé teszi a mobil felhasználókat hívások kezdeményezésére és fogadására
 akár az autójukból.
 Az AT&T vállalat 1947-ben megalkotta az első mobiltelefon hálózatot a Mobile
 Telephon Service-t (MTS).
 5,000 ügyféle volt és körülbelül heti 30 000 hívást bonyolítottak rajta.
 A cella technológia bevezetése lehetővé tette a frekvenciák sokszori újrahaszno
sítását kis szomszédos területeken, melyeket alacsony teljesítményű adók
 segítségével fedtek le.
 Ez lehetővé tette gazdaságilag megvalósítható módon a mobiltelefonok széles
 körben való elterjedését.
\end_layout

\begin_layout Standard
A mobil telefonok fejlődése jól nyomon követhető az egymást követő generációkon,
 a korai "0G" szolgáltatásokon keresztül az első generációs (1G) analóg
 cellás hálózatok és második generációs (2G) digitális mobil hálózatokon
 át a harmadik generációs (3G) szélessávú adat szolgáltatásokig.
 Napjainkban fejlődnek és egyre inkább elterjednek a negyedik generációs
 (4G) native-IP hálózatok.
\end_layout

\begin_layout Subsubsection*

\series bold
Cellák koncepciója
\end_layout

\begin_layout Standard
1947-ben Douglas H.
 Ring és W.
 Rae Young a Bell laboratórium mérnökei javasolták a hatszögletű cellák
 használatát a mobil hálózatokban.
 Akkoriban ez még nem volt megvalósítható csupán két évtizeddel később,
 mikor Richard H.
 Frenkiel, Joel S.
 Engel és Philip T.
 Porter mérnökök kiterjesztették a korábbi javaslatot és egy sokkal részletesebb
 tervet dolgoztak ki.
 Porter volt, aki először javasolta, hogy az adótornyok használják a már
 jól ismert irányított antennákat, annak érdekében, hogy redukálják az interfere
nciát és növeljék a csatornák újrahasznosíthatóságát.
\begin_inset Wrap figure
lines 0
placement o
overhang 0in
width "50col%"
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename Transmitting_tower_top_us.jpg
	scale 50

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Többirányú mobilhálózati antenna
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ezekben a korai időkben a mobilkészüléknek az adótorony által lefedett körzetben
 kellett maradnia, ahhoz hogy szolgáltatás folyamatos maradjon, vagyis a
 szolgáltatás nem volt folytonos, átjárható az egyes cellák között.
 A koncepciók, mint a frekvencia újrahasználás és az átadás (handoff vagy
 handover) számos új mobiltelefon hálózati koncepciók alapját képezték.
 1970-ben Amos E.
 Joel Bell Laboratórium mérnöke feltalálta a három oldalú antennát, hogy
 segítse a hívások átadásának folyamatát egyik cellából a másikba.
\end_layout

\begin_layout Subsection
Mobilhálózatokban gyakran használt kifejezések leírása
\end_layout

\begin_layout Subsubsection*

\series bold
Hozzáférési Technológiák
\end_layout

\begin_layout Description

\series bold
FDMA
\series default
 (Frequency Division Multiple Access) a leggyakoribb analóg rendszer.
 Ez a technika a spektrum frekvenciatartományokra való feldarabolásán alapszik
 és egy frekvenciasávot társít egy felhasználóhoz.
 Egy csatornát egy időben csak egy előfizető használhat, így egy csatorna
 lezárul a beszélgetés idejére más felhasználók elől, amíg le nem teszik,
 vagy át nem adódik a beszélgetés egy másik csatornának.
 A "full-duplex" FDMA átvitelnek két csatornára van szüksége, egy az adatok
 küldésére és egy másik a fogadására.
 FDMA technikát az első generációs analóg rendszerekben használták.
\end_layout

\begin_layout Description

\series bold
TDMA
\series default
 (Time Division Multiple Access) nagyobb kapacitásra volt képes, mert az
 egyes frekvenciákat időszeletekre (time slot) osztotta.
 TDMA rendszerben a felhasználók az egész frekvenciatartományt használhatták,
 több felhasználó osztozott ugyanazon a frekvencia csatornán amiből egy-egy
 időszeletet kaptak.
 TDMA a második generációs mobil hálózatok domináns technológiája.
\end_layout

\begin_layout Description

\series bold
CDMA
\series default
 (Code Division Multiple Access) szórt spektrumú technológián alapul.
 Titkosított adat átvitelt is lehetővé tette, ezért régóta használják katonai
 célokra.
 CDMA megnövelte a spektrum teljesítő képességét azzal, hogy a felhasználók
 az összes csatornát használhatják egy időben.
 Az adások az egész hullámsávot kihasználják, és minden hang vagy adat híváshoz
 egy egyedi kód tartozik, ami megkülönböztethetővé teszi egymástól a hívásokat.
 
\end_layout

\begin_layout Subsubsection*

\series bold
Mobil hálózati szabványok
\end_layout

\begin_layout Description

\series bold
PSTN
\series default
 (Public Switched Telephone Network) nyilvános vonalkapcsolt telefonhálózat.
 Telefon vezetékek, optikai kábelek, mikrohullámú átviteli állomások, kommunikác
iós műholdak és tengeralatti telefon kábelek kötik össze a kapcsolási központoka
t, hogy bármely telefon készülékkel felvehessük a kapcsolatot a világon.
 Eredetileg a hálózat analóg, vezetékes telefon rendszer volt, PSTN majdnem
 teljesen digitális, mobil és vezetékes telefonokat is tartalmaz.
 Egyetlen globális címtartománya van a telefonszámoknak, melyet a E.163 és
 E.164 szabványok írnak le.
 Az összekapcsolt hálózatok és az egységes számozásnak köszönhetően bármely
 telefonról hívható bármely másik készülék.
\end_layout

\begin_layout Description

\series bold
GSM 
\series default
(Global System for Mobile communication) ezt a szabványt az ETSI (European
 Telecommunications Standards Institute) a második generációs (2G) mobilhálózati
 protokollok leírására.
 A GSM sztenderd váltotta le az első generációs (1G) analóg hálózatot egy
 új, digitális, teljes kétirányú kommunikációt lehetővé tevő, vonalkapcsolt
 hálózat bevezetésével.
 Ezt később kiegészítették azzal, hogy belevették az adatkommunikációt is
 a szabványba, először vonalkapcsolt átvitellel, majd csomagkapcsolt átvitellel:
 GPRS (General Packet Radio Services) és EDGE (Enhanced Data rates for GSM
 Evolution vagy EGPRS).
\end_layout

\begin_layout Description

\series bold
GPRS 
\series default
(General Packet Radio Service) egy csomagkapcsolt szolgáltatás 2G és 3G
 kommunikációs rendszerekben.
 A GPRS-t az ETSI szabványosította, napjainkban a 3GPP (3rd Generation Partnersh
ip Project) tartja karban a szabványt.
 A GPRS szolgáltatás jellemzője a változó teljesítmény és késés, melyek
 mértéke a rendszert egyidejűleg használók számától függ.
 A vonal kapcsolt rendszerrel ellentétben, ahol szolgáltatás minősége (Quality
 of Service) biztosított a kapcsolat ideje alatt.
 2G-s rendszerben a GPRS által biztosított adatráta 56–114 kbit/s.
 A 2G és GPRS technológiák kombinációját néha 2.5G-nek szokták hívni, ami
 a 2G és a 3G mobil technológiák között helyezkedik el.
 Mérsékelt sebességű adatátvitelt biztosít a GSM rendszerben, az addig kihasznál
atlan több csatornás idő osztásos (TDMA: Time division multiple acces) technológ
ia segítségével.
\end_layout

\begin_layout Description

\series bold
EDGE
\series default
 (Enhanced Data rates for GSM Evolution), más néven EGPRS (Enhanced GPRS)
 mobiltelefon technológia, ami nagyobb adatátviteli sebességet tesz lehetővé.
 EDGE a 2003 év elején került bevezetésre a GSM hálózatokban.
 A 3GPP szabványosította és GSM család részévé vált.
 Kifinomult kódolási eljárások bevezetésének köszönhetően megnőtt a csatornánkén
t elérhető bitráta, háromszoros kapacitás és teljesítmény beli növekedést
 eredményezett a hagyományos GSM/GPRS kapcsolathoz képest.
 A továbbfejlesztett EDGE kisebb késést és több mint kétszeres teljesítmény
 növekedést biztosít.
 A legnagyobb bitráta elérheti a 1Mbit/s-ot, átlagosan pedig a 400kbit/s-ot.
\end_layout

\begin_layout Description

\series bold
W-CDMA
\series default
 (Wideband Code Division Multiple Access) egy 3G mobilhálózati rádiós interfész
 sztenderd.
 A leggyakrabban használt tagja az Universal Mobile Telecommunications System
 (UMTS) családnak és néha az UMTS szinonimájaként használják.
 A DS-CDMA csatorna hozzáférési és FDD duplex módszereket alkalmazza, hogy
 nagyobb sebességre legyen képes és több felhasználót tudjon kiszolgálni
 a TDMA és TDD (time division duplex) rendszerekhez képest.
 Ugyanazt a központi hálózatot használja, mint a 2G GSM hálózat.
 Code Division Multiple Access kommunikációs hálózat sok cég közreműködésével
 jött létre, de a CDMA (inkább W-CDMA) cellás telefon hálózat fejlesztésében
 a Qualcomm dominált.
 Qualcomm volt az első cég, akinek sikerült alkalmazható és költséghatékony
 megoldást találnia: ez volt a korai IS-95 rádióinterfésze sztenderd, melyből
 a CDMA2000 (IS-856/IS-2000) fejlődött ki.
 CDMA2000 hálózatok széles körben elterjedtek különösen Amerikában.
 Azonban az eltérő követelmények és felépítés megakadályozta a globális
 elterjedését.
 A meglévő rádiós interfészekkel való inkompatibilitás és a nagy költséggel
 járó fejleszthetőség ellenére a W-CDMA egy meghatározó szabvánnyá vált.
 A W-CDMA egy pár 5 MHz széles rádió csatornát használ, míg a CDMA2000 egy
 vagy több pár 1.25 MHz széles rádió csatornát.
 Habár a W-CDMA szintén CDMA átviteli technikát alkalmaz, akár a CDMA2000,
 a W-CDMA nem egyszerűen egy széles sávú verziója a CDMA2000-nak.
 Mérnöki szempontból a W-CDMA különböző optimalizálási lehetőséget nyújt
 költség, kapacitás és teljesítmény között.
 Specifikációk egész halmazát tartalmazza, melyek részletesen definiálják
 a protokollokat, a kommunikációt a készülékek és a tornyok között, hogyan
 kell modulálni a szignálokat és azt is hogyan kell az adatokat strukturálni.
\end_layout

\begin_layout Description

\series bold
UMTS
\series default
 (The Universal Mobile Telecommunications System) harmadik generációs mobil
 hálózati rendszer.
 A 3GPP (3rd Generation Partnership Project) fejlesztette ki és tartja karban.
 W-CDMA hozzáférési technológiát használ a jobb hálózati kihasználtság és
 sávszélesség miatt.
 UMTS specifikál egy teljes hálózati rendszert, melybe beletartozik a hozzáférés
i hálózat (UMTS Terrestrial Radio Access Network, UTRAN), a központi hálózat
 (core network) és a felhasználók SIM általi azonosítása.
 Az EDGE és a CDMA2000 ellentétben az UMTS új bázis állomást és frekvencia
 allokációs módszert igényel.
 Az UMTS által támogatott maximális adat átviteli ráta 42 Mbit/s, ha HSPA+
 alkalmaznak a hálózatban és 7.2 Mbit/s HSDPA használat esetén.
 Ezek a sebességek szignifikánsan gyorsabbak, mint a GSM 9.6 kbit/s-os hibajavítá
sos vonalkapcsolt adatátvitele, vagy a CDMAOne csatornák 14.4 kbit/s rátája.
 2006 óta UMTS hálózatokat számos országban feljavították a High Speed Downlink
 Packet Access (
\series bold
HSDPA
\series default
) technikával, melyet néha 3.5G néven emlegetnek.
 HSDPA segítségével a letöltési sebesség elérheti a 21 Mbit/s-ot.
 A feltöltési sebesség javítását támogató technológia a High-Speed Uplink
 Packet Access (
\series bold
HSUPA
\series default
).
 Az első UMTS hálózatot 2002-ben indították be, nagy hangsúlyt fektetve
 az olyan mobil alkalmazásokra, mint a mobil TV és videóhívás.
 A nagy adatátviteli sebességet gyakran Internet elérésre használják.
 
\end_layout

\begin_layout Description

\series bold
LTE
\series default
 (Long-Term Evolution) 4G LTE, a legújabb sztenderd a mobiltelefonok és
 adat terminálok közötti nagy sebességű vezeték nélküli adatkommunikációra.
 GSM/EDGE és UMTS/HSPA hálózati technológiákon alapszik, de nagyobb kapacitást
 és sebességet nyújt különböző rádiós interfészek együttes alkalmazásával.
 A világ első publikus LTE szolgáltatója a TeliaSonera Osloban és Stockholmban.
 Várhatóan az LTE lesz az első igazán globális mobiltelefon sztenderd, habár
 a országonként különböző frekvenciasávok használata miatt csak a többsávos
 telefonok lesznek képesek kihasználni minden országban az LTE szolgáltatást.
 Míg a korábbi technológiák 28 Mbit/s elméleti maximumot támogatták, az
 LTE 326 Mbit átvételére lesz képes másodpercenként, 20 MHz széles frekvenciatar
tományon.
 Az LTE sztenderd csak IP hálózatokat támogatja.
 A GSM, UMTS és CDMA2000 hagyományos vonalkapcsolt hálózatok, így az LTE-vel
 való együttműködés miatt át kell tervezni a hálózatokat.
 Erre több fél megoldást dolgoztak ki:
\end_layout

\begin_layout Description

\series bold
VoLTE 
\series default
(Voice Over LTE) megközelítés IP Multimedia Subsystem (IMS) hálózaton alapszik.
 Ezzel a megoldással a hangszolgáltatás adatfolyamként továbbítódik az LTE
 állomáson keresztül.
 Ez azt jelenti, hogy nem kell módosítani a hagyományos vonalkapcsolt hálózatot,
 képes lesz a 4G-s hívást adatcsomagként továbbítani.
 Másik megközelítés a 
\series bold
CSFB 
\series default
(Circuit Switched Fallback).
 Eben az esetben az LTE csak adatcsomag szolgáltatást nyújt és a hanghívások
 vonalkapcsolt hálózatban dolgozódnak fel.
 Ezt a megoldást használva az operátoroknak csak az MSC-t kell frissíteniük
 IMS telepítés helyett.
 Hátránya a hosszabb hívás kiépítési idő.
 A jobb minőségű hang biztosításához a 3GPP megköveteli legalább az AMR-NB
 kodek (narrow band) használatát, de a javasolt beszéd kodek VoLTE-hoz az
 Adaptive Multi-Rate Wideband, avagy a HD Voice.
\end_layout

\begin_layout Subsubsection*

\series bold
Mobil hálózat elemei
\end_layout

\begin_layout Description
BSC (Base Station Controller) több tíz esetleg több száz BTS-t irányít.
 A BSC rádió csatornák kiosztásáért felelős, mérési eredményeket fogad a
 mobil készülékektől és a BTS-ek közötti handover-eket kezeli.
 BSC fő funkciója összekötőként viselkedik a BTS-ek és a Mobile Switching
 Center (MSC) között.
 Általában a hálózatokban gyakorta úgy strukturálják, hogy számos BSC-t
 elosztanak a régiókban közel a BTS-ekhez, melyek egy nagy központosított
 MSC site-tal állnak kapcsolatban.
 MSC-ket és Service GPRS Support Node-okat (SGSN) is kiszolgál (abban az
 esetben ha GPRS-t használ).
 
\end_layout

\begin_layout Description
BSS (Base Station Subsystem) része a hagyományos mobilhálózatnak (2G, GSM)
 és a kommunikációt biztosítja a mobiltelefon és a hálózati kapcsolóalrendszer
 között.
 A BSS transzkódolást végez, rádió csatornákat rendel a mobiltelefonokhoz,
 lapozást kezel, és még sok más feladatot ellát a rádiós hálózatban.
\end_layout

\begin_layout Description
BTS (Base Transceiver Station) tartalmazza a rádió szignálok átviteléhez
 és fogadásához szükséges berendezéseket, antennákat, valamint a bázisállomással
 (BSC) történő kommunikáció dekódoláshoz és titkosításhoz szükséges eszközöket.
 Valójában nem más, mint egy pikócella sok rádió adó-vevővel (TRX), amik
 lehetővé teszik különböző frekvenciák kiszolgálását.
 Egy BTS-t a "szülő
\begin_inset Quotes srd
\end_inset

 bázis állomás (BSC) vezérel.
\end_layout

\begin_layout Description
MS (Mobile Station) azaz maga a mobil készülék, amivel a felhasználó hívást
 kezdeményezhet és fogadhat.
 Ez a terminológia 2G rendszerekre vonatkozik, mint a GSM.
 3G rendszerekeben a mobile station helyett 
\begin_inset Quotes sld
\end_inset

user equipment
\begin_inset Quotes srd
\end_inset

-ként (UE) hivatkoznak rá.
\end_layout

\begin_layout Description
RNC (Radio Network Controller) az UMTS mobil hálózat (UTRAN) irányító egysége
 és a hozzá kapcsolt 
\begin_inset Quotes sld
\end_inset

Node B
\begin_inset Quotes srd
\end_inset

-k kontrollálásáért felelős.
 BSC-nek 3G-s hálózati megfelelője, hasonló munkát végez: az üzenetek encryptálá
sa és erőforrás kezelés.
 Az RNC kapcsolatban áll a Circuit Switched Core Network-hez a Media Gateway-en
 (MGW) keresztül és a Serving GPRS Support Node-on (SGSN) keresztül a Packet
 Switched Core Network-höz.
\end_layout

\begin_layout Description
Node-B Ezt a terminust az UMTS hálózatban használják és megfelel a BTS-nek
 a GSM-ben.
 A mobil készülékek Node B-n tudnak egymással kommunikálni.
 Az RNC kontrollálja ezt a hálózati elemet.
\end_layout

\begin_layout Description
VLR (Visitor Location Register) egy adatbázis azon előfizetők számára, akik
 beléptek az adott VLR-hez tartozó Mobile Switching Center (MSC) területére.
 Minden egyes bázisállomáshoz pontosan egy VLR tartozik, így az előfizető
 egy időben mindig csak egy VLR-ben szerepel.
 Az adatok vagy a mobil készülékről (MS), vagy a HLR-től érkeznek.
 Amint érzékel egy új MS-t az MSC, azonnal készít egy új bejegyzést a VLR-jében
 és frissíti a HLR-ben az előfizető helyzetét.
\end_layout

\begin_layout Description
HLR (Home Location Register) egy központi adatbázis, ami tartalmazza az
 összes mobiltelefon előfizetője adatát, akik használhatják hálózatot.
 
\end_layout

\begin_layout Description
M-MGW (Mobile Media Gateway) egy olyan eszköz, ami a digitális média folyamokat
 konvertálja (transzkódolja) a különböző telekommunikációs hálózatok között
 (PSTN, 2G, 3G, stb.), illetve lehetővé teszi a különféle átviteli protokollok
 használatát (ATM, IP, TDM) .
 Általában az egyes hálózatok határán helyezkedik el, hogy biztosítsa az
 adatok konvertálását egyik hálózatból a másikba.
\end_layout

\begin_layout Description
SGSN (Serving GPRS Support Node) felelős a mobileszközök és kiszolgáló állomások
 közötti adat csomagok szállításáért.
 A feladatai közé tartozik az irányítás (routing), a helymeghatározás és
 a felhasználók azonosítása (authentication).
 
\end_layout

\begin_layout Description
GGSN (Gateway GPRS Support Node) központi eleme a GPRS hálózatnak, az internet
 elérését biztosítja a GPRS hálózat és a külső hálózatok között.
 Kívülről nézve a GGSN egy router, ami elrejti a GPRS hálózat infrastruktúráját
 a külső hálózattól.
 Mikor adat csomagokat kap megvizsgálja, hogy a felhasználó aktív-e, és
 ha igen akkor továbbítja a csomagot az SGSN-nek, aki kiszolgálja a mobil
 felhasználót.
\end_layout

\begin_layout Description
MSC (Mobil Softswitch Controller) elsődleges eleme a GSM/CDMA hálózatoknak,
 a hanghívások route-olásáért és az SMS, valamint más szolgáltatásokért
 felelős, mint a konferencia hívások, FAX, stb.
 Kiépíti, majd lebontja a kapcsolatokat, hívásokat, valamint kezeli a handover-e
ket.
\end_layout

\begin_layout Description
IMS (IP Multimedia Subsystem) egy architektúra az IP alapú multimédiás szolgálta
tásokhoz.
 Kezdetben a 3GPP arra fejlesztette ki, hogy terjesszék ki a GPRS-t Internet
 alapú szolgáltatásokkal.
 A könnyebb integrálhatóság miatt IETF protokollokat használnak ahol csak
 lehetséges, ilyen például a SIP (Session Initiation Protocol) .
\end_layout

\begin_layout Subsubsection*

\series bold
Mobil hálózat szolgáltatások
\end_layout

\begin_layout Standard

\series bold
SIM
\series default
 (Subscriber Identity Module) egyik fő jellemzője a GSM-nek a SIM bevezetése,
 a legtöbben SIM kártya néven ismerik.
 A SIM egy cserélhető okoskártya, mely az előfizető információt és telefonkönyve
t tartalmazhat.
 Lehetővé teszi a felhasználónak, hogy információkat tároljon és egy másik
 telefonban is fel tudja használni azokat.
 Ezentúl lehetővé teszi, hogy szolgáltatót váltson a felhasználó a készülék
 lecserélése nélkül, mivel csak a SIM kártyát kell lecserélnie.
 Néhány operátor blokkolja ezt a lehetőséget a SIM lezárásával, ez esetben
 a készülék csak az adott szolgáltató kártyáját fogadja el.
\end_layout

\begin_layout Standard

\series bold
WAP
\series default
 (Wireless Application Protocol): egy sztenderd technika a vezetéknélküli
 hálózatokon keresztül történő információ cserének.
 A WAP böngésző egy webböngésző a mobil készülékekhez.
 A WAP bevezetése előtt, a mobil szolgáltatóknak limitált lehetőségük volt
 az interaktív adatszolgáltatásra.
 Interaktivitást követelt az Internet és Web alkalmazások támogatása pl.:
 email kezelés, tőzsdei árak vagy a sporteredmények követése.
 A WAP sztenderd egy protokoll családot ír le, mely lehetővé teszi az interopera
bilitást a WAP és más különböző hálózati technológiák között, mint a GSM
 és a CDMA.
\end_layout

\begin_layout Standard

\series bold
Roaming
\series default
 egy általános kifejezés a mobil szolgáltatás kiterjesztésére olyan helyre,
 amely különbözik a szolgáltatás regisztrált helyétől.
 Roaming biztosítja a kapcsolatot vezetéknélküli eszköz és a hálózat között,
 a kapcsolat elvesztése nélkül.
 Hagyományos GSM Roaming definíció szerint (GSM Association Permanent Reference
 Document AA.39) a cella felhasználó képes automatikusan hívást indítani
 és fogadni, adatokat küldeni és fogadni, vagy más szolgáltatásokhoz kapcsolódni
, miközben utazik, elhagyja a hazai szolgáltatás által lefedett területet.
 
\end_layout

\begin_layout Standard

\series bold
Handover
\series default
 kifejezés (vagy handoff) arra a folyamatra utal, mikor egy folyamatban
 lévő hívást vagy adat folyamot átviszünk az egyik csatornáról a másikra.
 Erre akkor van szükség, mikor a készülék átlépi a cella határát, vagyis
 kilép az eddigi adótorony körzetéből és egy másik veszi át a kiszolgálását.
 Többféle handover létezik, attól függően, hogy a telefon melyik cellát,
 milyen irányba lépi át.
 Például abban az esetben, mikor a készülék nem csak egy cella határán van,
 hanem egy tartomány határán is, akkor nem csak egy másik toronyhoz (BTS
 vagy Node B) kerül át, hanem egy másik BSC vagy RNC-hez is.
\end_layout

\begin_layout Subsection
Mobilhálózatok fejlődése
\end_layout

\begin_layout Standard
Az első rádiótelefon szolgáltatást a '40-es évek végén vezették be Amerikában.
 Ez azt jelentette, hogy a mobil használók akár autóból is tudtak kapcsolódni
 a meglévő publikus telefonhálózathoz.
 1960-ban új rendszert indított a Bell Systems, amit IMTS-nek (Improved
 Mobile Telephone Service) hívtak, mely számos újítást hozott, például szélesebb
 sávszélességet.
 Az első analóg cellás rendszer ezen az IMTS rendszeren alapult és a 1970-es
 évek elején fejlesztették ki.
 A rendszer "cellás" volt, mert a lefedett területeket felosztották kisebb
 részekre, avagy cellákra.
 
\end_layout

\begin_layout Subsubsection*

\series bold
Első generáció 
\end_layout

\begin_layout Standard
Első generációs mobil rendszer az AMPS (Advance mobile phone system), melyet
 először az Egyesült államokban vezették be.
 Ez az egyik legjobb FDMA (Frequency Division Multiple Access) technológia,
 mely lehetővé teszi, hogy hanghívást bonyolíthat az egész országban.
\end_layout

\begin_layout Subsubsection*

\series bold
Második generáció
\end_layout

\begin_layout Standard
2G digitális cellás rendszer, melyet az 1980-as évek végén fejlesztették
 ki.
 Az új rendszer jobb minőséget és nagyobb kapacitást biztosít a felhasználóknak
 az analóg 1G rendszerhez képest.
 GSM (Global system for mobile communication) volt az első kereskedelemben
 működtetett digitális cellás rendszer, mely TDMA (Time division multiple
 acces) alapú.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\paragraph_spacing single
\noindent
\align center
\begin_inset Graphics
	filename Gsm_structures.svg.jpg
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
2G hálózat struktúrája
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A 2G technológiák biztosítanak különböző szolgáltatásokat, mint szöveges
 üzenet, kép üzenet és MMS (multi media messages) küldését.
 Az összes szöveges üzenet digitálisan titkosított, így csak a megfelelő
 címzett tudja fogadni és elolvasni az üzenetet.
 Idővel sokat fejlesztettek a rendszeren, így alakult ki a korábban már
 említett GPRS és az EDGE technológiák.
 
\end_layout

\begin_layout Subsubsection

\series bold
Harmadik generáció
\series default
 
\end_layout

\begin_layout Standard
3G kezdeményezés a készülék gyártóktól származott, nem pedig a telefonhálózatok
 operátoraitól.
 A fejlesztés 1996-ban kezdődött a Nippon Telephone & Telegraph (NTT) és
 az Ericsson vezetésével; 1997-ben az amerikai Telecommunications Industry
 Association (TIA) a CDMA-t választotta 3G technológiájának; 1998-ban az
 European Telecommunications Standards Institute (ETSI) ugyanezt tette és
 végül a széles sávú CDMA (W-CDMA) és a CDMA 2000 adaptálták az UMTS-hez
 (Universal Mobile Telecommunications System).
 W-CDMA és CDMA 2000 volt a két legnagyobb javaslat a 3G technológiára.
 A W-CDMA TDM-et (Time Division Multiplexing), ezzel ellentétben a CDMA
 2000 CDM-et (Code Division Multiplexing) eljárást használ.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename UMTS_structures.svg.jpg
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
3G hálózat struktúrája
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
3G rendszer gyorsabb kommunikációs szolgáltatást nyújt, beleértve a hang,
 fax és Internet szolgáltatásokat, melyek bármikor és bárhonnan elérhetőek.
 Az ITU féle IMT-2000 3G sztenderd tette lehetővé az innovatív applikációk,
 például multimédiás szórakoztatás, információ és helymeghatározás szolgáltatáso
k elterjedését a felhasználók között.
 Az első 3G hálózatot Japánban építették ki 2001-ben.
 2.5G hálózatok, mint a GPRS (Global Packet Radio Service) már elérhetőek
 voltak Europa bizonyos országaiban.
 3G technológia támogatja a 144 Kbps sávszélességet nagy sebességű mozgásnál
 (pl: járművek), 384 Kbps pl.
 egyetemek területén és 2 Mbps-ot állóhelyzetben (pl.: épületen belül).
 A maximális letöltési adatráta 384Kpbs, átlagosan 200 Kpbs és a feltöltés
 is ráta 64 Kpbs.
\end_layout

\begin_layout Subsubsection*

\series bold
Negyedik generáció 
\end_layout

\begin_layout Standard
Negyedik generációs (4G) mobil kommunikáció nagyobb adatátvitelre lesz képes,
 mint a 3G.
 Az adatráta tervezett mértéke 100 Mbps .
\end_layout

\begin_layout Standard
A 4G szolgáltatás biztosítani fogja a szélessávú, nagy kapacitású, nagy
 sebességű adatátvitelt, így lehetővé teszi többek között a jó minőségű,
 nagy felbontású videótelefonálást.
 A 2008-as ITU szabvány szerint legfeljebb 100 Mbit/s átviteli sebesség
 elérése lesz képes egy gyorsan mozgó készülék esetén (például: kocsiban,
 vonaton) és akár 1Gbit/s adatráta is elérhető egyéb esetekben.
 Két 4G rendszertervet dolgoztak ki, amit már kereskedelmi forgalomban is
 használnak, ez a Mobile WiMAx és az LTE.
 Egyik megoldás sem teljesen teljesíti az ITU szabványt, ezért ezeket még
 
\begin_inset Quotes sld
\end_inset

hivatalosan
\begin_inset Quotes srd
\end_inset

 nem tartják a szakemberek negyedik generációs hálózatnak, habár az operátorok
 már annak hirdetik.
 Mindkét technológiát fejlesztik, hogy megfeleljen a 4G szabvány elvárásainak,
 főleg az adatátviteli sebesség kapcsán.
 Egyáltalán nem támogatja már a hagyományos vonalkapcsolt szolgáltatásokat,
 csak az internet protokollra (IP) épülőket, mint amilyen az IP telefonálás.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename interphaseLTEnetwork.jpg
	scale 60

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
4G és 3G hálózat architektúrája
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
A hálózatok vizsgált adatai
\end_layout

\begin_layout Standard
A lenti táblázat tartalmazza az átviteli sebességeket különféle technológiák
 esetén.
 Ezek a sebesség adatok módosulhatnak attól függően, hogy milyen rádiótechnológi
át használ a telefonhálózat operátora (CDMA, FDD, stb.) Amint látható, a
 2G és 3G hálózatok adatrátája egyre inkább növekszik, így lehetővé téve
 a nagyobb sávszélességigényű szolgáltatások bevezetését, mint a HD audió
 és videó szolgáltatások.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="right" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Technológia
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Adatráta
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GSM
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9.6Kbps 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GSM/GPRS 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
40Kbps-144Kbps 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
EDGE 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
474Kbps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UMTS (WCDMA) 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
384Kbps-2Mbps 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CDMA-One 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9.6Kbps-76.8Kpbs
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CDMA 2000 1x EV-DO 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
384Kbps – 2.4Mbps 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CDMA 2000 1x EV-DV
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.09Mbps 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CDMA 2000 3x
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2Mbps – 4Mbps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HSDPA 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8Mbps – 10Mbps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LTE
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
le 1 Gbps, fel 500 Mbps.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Technológiák és az elérhető adatráták
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A hálózat további fontos tulajdonságai amik mérésre kerülnek a jelerősség
 és UDP tesztek esetén a jitter.
 A jelerősség - amit dBm-ben mérnek - indikálja a szolgáltatás minőségét.
 Az értéke sok paramétertől függ, többek között az adótoronytól való távolságtól
, a természeti akadályoktól, amik a készülék és a torony között vannak (erdő,
 hegy, stb.) és az időjárástól is függhet.
 A telefonkészüléken 5 darab kis osztás szokta jelezni a jelerősséget.
 Minél több osztás aktív, annál erősebb a jel, annál jobb a szolgáltatás.
 Ha kicsi a jel erősség, akkor probléma léphet fel a szolgáltatások minőségében,
 például akadozik a hangátvitel, nagyon ingadozik az átviteli sebesség.
 A ritkán lakott területeken is kicsi szokott lenni a jelerősség.
 A mérésekből kiderülhet, hogy olyan helyen is rossz a jel minősége, ahol
 ezt nem is várnánk.
 Ilyen esetben az operátorok feladata, hogy kiderítsék ennek az okát.
\end_layout

\begin_layout Standard
A jitter a csomagok megérkezési ideje közötti különbség, ami a hálózati
 torlódásból, időzítési problémából vagy útvonal váltásból eredhet.
 Ez akkor jó, ha kicsi az érték, azaz a csomagok sűrűn követik egymást és
 a csomagok beérkezési idejei között nem nagy a különbség.
 A jitter nagysága, illetve nagy, sűrű változása okozhatja a telefonbeszélgetése
k közbeni hangkiesést, akadozást, illetve a videolejátszás során a képek
 kiesését, szaggatást.
 Az UDP-t használó tesztek során a jelentések tartalmazzák az aktuális jitter
 értéket.
 Ezen értékeket figyelve derülhet ki a magas jitter érték, illetve a gyakori,
 nagy különbségek is problémát jelezhetnek a hálózatban.
 
\end_layout

\begin_layout Section
Android platform bemutatása
\end_layout

\begin_layout Standard
Az Android fejlesztő környezet széleskörű támogatást nyújt a fejlesztőknek
 a telefon és a hálózat adatainak lekéréséhez, ami nagyban megkönnyíti az
 alkalmazás fejlesztését.
 A nyílt fejlesztői környezettel az Android lehetőséget biztosít a fejlesztőknek
, hogy magas színvonalú és innovatív alkalmazásokat készítsenek.
 A fejlesztők kihasználhatják például az adott eszköz hardver képességeit,
 hozzáférhetnek a felhasználó adataihoz és akár futtathatnak háttér szolgáltatás
okat is.
\end_layout

\begin_layout Subsection
Android komponensek
\end_layout

\begin_layout Standard
Az Android fejlesztőkörnyezetnek több komponense létezik, mindegyiknek különböző
 célja és szerepe van a programban.
 Ezek általában egymással szoros kapcsolatban állnak, de önálló példányban
 léteznek és saját életciklusuk van.
\end_layout

\begin_layout Subsubsection
Activity
\end_layout

\begin_layout Standard
Egy felhasználói felülettel rendelkező képernyőt, ablakot Activity-nek nevezünk.
 Például egy zenelejátszó program Activity-je lehet, ami megjeleníti a lejátszó
 felületet, és egy másik, ahol kiválaszthatja a felhasználó a lejátszandó
 zenéket.
 Minden alkalmazásnak van egy kitüntetett "fő
\begin_inset Quotes srd
\end_inset

 Activity-je, ha a felhasználó elindítja a programot ez az ablak jelenik
 meg.
 Habár mindegyik Activity a zenelejátszó programban együttműködve adja a
 teljes felhasználói élményt, mégis mindegyik független a többitől.
 
\end_layout

\begin_layout Standard
A hagyományos applikációkkal ellentétben az Android programoknak nincs kontrollj
uk az életciklusuk felett.
 Így az alkalmazás komponenseinek figyelnie kell a program állapotváltozására
 és aszerint reagálni.
 A komponensek állapota befolyásolja a program állapotát, mely meghatározza
 a program prioritását a rendszerben.
 Az Activity-k úgynevezett "Activity stack
\begin_inset Quotes srd
\end_inset

-en, azaz egy Last-In-First-Out adatszerkezetben tárolódnak.
 Mikor egy új Activity elindul, az előtte futó kerül a stack tetejére.
 Ha az előtérben lévő, aktív Activity bezáródik vagy a felhasználó megnyomja
 a Vissza gombot, akkor a verem tetején lévő kerül előtérbe.
 Ha az Activity-t megsemmisíti a rendszer, mert már nincs rá szükség, akkor
 felszabadítja annak erőforrásait és eltávolítja a veremből.
 A folyamatot az alábbi kép szemlélteti.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename stack.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Activity-ket tartalmazó verem
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Az Activity-nek négy állapota lehet:
\end_layout

\begin_layout Itemize

\series bold
Aktív 
\series default
(Active), ebben az állapotban a verem tetején lévő Activity lehet, ilyenkor
 az ablak előtérben van és képes fogadni a felhasználói utasításokat.
 Az Android rendszer mindent megtesz annak érdekében, hogy ez az Activity
 futhasson.
 Így, ha kevés az erőforrás, a memória, akkor leállítja a verem alján lévőket
 és felszabadítja azok erőforrását.
 Mikor egy másik Activity lesz az aktív, akkor az előbbi állapota felfüggesztett
 lesz.
\end_layout

\begin_layout Itemize

\series bold
Felfüggesztett
\series default
 (Paused) állapotban az Activity látható maradhat, de nem reagál felhasználói
 eseményekre, nincs fókusza.
 Ez akkor fordulhat elő, ha az előtérben lévő ablak átlátszó vagy nem fedi
 le a teljes képernyőt.
 
\end_layout

\begin_layout Itemize

\series bold
Leállt 
\series default
(Stopped), ekkor az Activity nem látható, leállt.
 Az erőforrások még nem szabadulnak fel és a veremből sem kerül ki.
 A leállt Activity-k prioritása a legkisebb, így ezeket terminálja legelőször
 a rendszer, ha erőforrásra van szüksége.
\end_layout

\begin_layout Itemize

\series bold
Inaktív 
\series default
(Inactive) állapotba kerül, ha terminálva lett vagy mielőtt elindul.
 Ezek az Activity-k nincsenek a veremben és csak újraindításkor válhat aktívvá.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename activity_lifecycle.png
	scale 60
	clip

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Activity életciklusa
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Android rendszer biztosítja, hogy az egyes Activity-k reagálhassanak az
 állapotváltásra.
 A lenti képen láthatóak az Activity életciklusai.
 A téglalapok visszahívó (callback) metódusokat szimbolizálnak.
 Ezek felhasználhatók különféle műveletek végrehajtására az egyes átmenetek
 során.
\end_layout

\begin_layout Itemize

\series bold
onCreate() 
\series default
Az Activity létrejöttekor hívódik meg.
 Itt kell az összes statikus adatot inicializálni, például nézetek létrehozása.
 Ez a függvény kap egy Bundle típusú paramétert, mely az Activity előző
 állapotát tartalmazza.
 Mindenképp onStart() metódus hívás követi.
\end_layout

\begin_layout Itemize

\series bold
onRestart() 
\series default
egy leállított Activity újraindítása során hívódik meg.
 OnStart() metódus követi.
\end_layout

\begin_layout Itemize

\series bold
onStart() 
\series default
az előtt hívódik, hogy az Activity láthatóvá válna a felhasználó számára.
 OnResume() metódus hívódik ezután, ha az Activity előtérbe kerül vagy az
 onStop(), ha háttérbe kerül.
\end_layout

\begin_layout Itemize

\series bold
onResume() 
\series default
akkor hívódik, ha az Activity a verem tetejére kerül, mielőtt aktívvá válna
 és felhasználói inputot fogadna.
 Minden esetben onPause() hívódik utána.
\end_layout

\begin_layout Itemize

\series bold
onPause() 
\series default
egy másik alkalmazás folytatása váltja ki ezt a metódushívást.
 Itt célszerű elmenteni az adatokat, illetve leállítani az erőforrás igényes
 műveleteket, mint például az animáció lejátszást.
\end_layout

\begin_layout Itemize

\series bold
onStop() 
\series default
az Activity leállásakor vagy egy másik Activity aktívvá válásakor hívódik.
 Ezután onRestart() hívás jelzi, hogy újra aktívvá vált az Activity.
 
\end_layout

\begin_layout Itemize

\series bold
onDestroy() 
\series default
az Activity megszűnésekor kerül meghívásra, amit vagy a rendszer vált ki,
 mert erőforrásra van szüksége vagy meghívták rá a 
\shape italic
finish()
\shape default
 metódust.
\end_layout

\begin_layout Subsubsection*
Service 
\end_layout

\begin_layout Standard
A Service (szolgáltatás) egy háttérben, párhuzamosan futó komponens.
 Sokáig futó műveletek végrehajtására használható és nem biztosít felhasználói
 felületet.
 Ilyen művelet lehet például a zenelejátszás, miközben a felhasználó más
 alkalmazást használ, anélkül, hogy a háttérben futó zenelejátszás blokkolná
 vagy zavarná a másik alkalmazást, illetve a felhasználót.
 Egy másik komponens, mint például egy Activity indíthat Service-t és interakció
ba léphet vele.
 Egy új service-t indíthat egy komponens a 
\shape italic
startService()
\shape default
 metódus hívással, ami akkor is fut, ha a hívó komponens megszűnik.
 A service automatikusan leáll, ha a feladatát befejezte.
 Ez a feladat lehet például egy fájl feltöltése.
 Másik működési módja a service-nek az úgynevezett kötött (bound) service.
 Egy komponens a 
\shape italic
bindService()
\shape default
 metódussal tud összeköttetésbe kerülni ezzel a service-szel.
 Több komponens is kapcsolódhat egy service-hez, ha már egy komponens se
 kapcsolódik a szolgáltatáshoz, akkor megszűnik a service.
 Fontos callback metódusok, melyek implementálhatók egy service-hez:
\end_layout

\begin_layout Itemize

\series bold
onStartCommand() 
\series default
akkor hívódik meg, mikor egy másik komponens meghívja a 
\shape italic
startService()
\shape default
 metódust.
 Ha ez a metódus implementálásra kerül és befejezte a működését, akkor le
 kell állítani a 
\shape italic
stopSelf()
\shape default
 vagy 
\shape italic
stopService()
\shape default
 metódussal.
 Ha csak kötött szolgáltatásként szeretnénk használni, akkor nem kell implementá
lni ezt a metódust.
\end_layout

\begin_layout Itemize

\series bold
onBind()
\series default
 metódus hívódik meg, ha egy másik komponens akar kapcsolódni a service-hez
 a 
\shape italic
bindService()
\shape default
 függvény hívással.
 Ha nem akarjuk megengedni a szolgáltatáshoz való csatlakozást akkor null-t
 kell küldeni visszatérő paraméterként, egyébként pedig egy IBinder típusú
 objektumot, amin keresztül a hívó komponens kommunikálhat a szolgáltatással.
\end_layout

\begin_layout Itemize

\series bold
onCreate()
\series default
 a service létrehozásakor hívódik az 
\shape italic
onStartCommand()
\shape default
 előtt.
\end_layout

\begin_layout Itemize

\series bold
onDestroy()
\series default
 a rendszer hívja ezt a metódust, mikor a szolgáltatást már nem használják
 többé és meg kell szüntetni.
 Itt kell felszabadítani a foglalt erőforrásokat, szálakat.
\end_layout

\begin_layout Subsubsection*
IntentService
\end_layout

\begin_layout Standard
Az IntentService a Service osztályból öröklődik és aszinkron kéréseket kezel
 (Intent-eken keresztül).
 A kliens küld egy kérést a startService(Intent) híváson keresztül és a
 szolgáltatás elindul, majd leállítja magát ha végrehajtotta a feladatát.
 Egyszerre csak egy kérést szolgál ki, ha több érkezik be, akkor egymás
 után lesznek kiszolgálva.
 Ez a módszer gyakran használt eljárás annak érdekében, hogy tehermentesítsük
 az applikáció fő szálát.
 A használatához az IntentService osztályból kell származtatni és implementálni
 az 
\shape italic
onHandleIntent(Intent)
\shape default
 metódust.
 Az IntentService meg fogja kapni ezt az Intent-et, elindítja az új szálat
 és megállítja szolgáltatást.
\end_layout

\begin_layout Subsubsection
Broadcast receiver
\end_layout

\begin_layout Standard
A broadcast receiver egy olyan komponens, amely válaszol a rendszerszintű
 üzenetekre.
 Számos rendszerüzenetet kezelhet például a képernyő kikapcsolásról vagy
 az akkumulátor töltöttségének csökkenéséről érkező üzeneteket.
 Az alkalmazás is kezdeményezhet ilyen üzenet küldést, például ha egy másik
 alkalmazásnak akar üzenetet küldeni.
 A service-hez hasonlóan nem rendelkezik felhasználói felülettel.
\end_layout

\begin_layout Standard
Az egyes komponenseket egy aszinkron üzenettel lehet aktiválni, amit Intent-nek
 neveznek.
 Ez kapcsol össze komponenseket futási időben, akkor is, ha a komponens
 egy másik applikációhoz tartozik.
 Az Intent közvetíthet üzenetet másik komponensnek, például, hogy jelenítsen
 meg egy képet vagy nyisson meg egy weboldalt.
\end_layout

\begin_layout Subsubsection*
Intent
\end_layout

\begin_layout Standard
Az intent üzenetekkel futás idejű kapcsolatot, kötést létesíthetünk Android
 komponensek között.
 Intent objektum egy adatstruktúra, ami általában a végrehajtandó művelet
 absztrakt leírását tartalmazza, illetve a fogadó komponens számára fontos
 információkat is tartalmazhat.
 Ezen felül tartalmaz a rendszer számára lényeges információkat például:
 a fogadó komponens kategóriáját.
 
\end_layout

\begin_layout Subsubsection
Application 
\end_layout

\begin_layout Standard
Ezen osztály segítségével lehet figyelni, karbantartani az egész applikáció
 állapotát.
 A saját application objektumunkat az AndroidManifest.xml fájl <application>
 tagja írja le, ami azt jelenti, hogy az osztály példánya létrejön az applikáció
 indulása elején.
 Általában nincs szükség erre az objektumra.
 A többi Android objektumból elérhető az Application objektum a 
\shape italic
getApplication()
\shape default
 metódus segítségével.
\end_layout

\begin_layout Standard
Ha szükség van egy globális Context objektumra (például BroadcastReceiver
 objektum beregisztrálásához), itt található a 
\shape italic
getApplicationContext()
\shape default
 függvény, mely visszaadja ezt a Context objektumot.
\end_layout

\begin_layout Subsection
Futási környezet és konfiguráció
\end_layout

\begin_layout Standard
Az Android SDK tartalmaz egy alap könyvtárat, mely megvalósítja a Java programoz
ási nyelv túlnyomó részét.
 
\end_layout

\begin_layout Standard
Minden alkalmazás saját szálon fut és saját Dalvik virtuális gép példánnyal
 rendelkezik, így egymástól elkülönítve tudnak futni az egyes alkalmazások.
 A Dalvik VM (virtuális gép) a Linux kernelre támaszkodik az alacsony szintű
 funkcionalitás használata során, mint például a szálkezelés.
 A Linux továbbá biztonsági, memória és hálózat kezelési szolgáltatásokat
 is nyújt.
\end_layout

\begin_layout Standard
Az Android operációs rendszer megvalósítja a 
\shape italic
legkisebb jogosultság elvét, 
\shape default
így az alkalmazás csak a számára szükséges komponensekhez fér hozzá.
 Egy alkalmazás engedélyt kérhet arra, hogy komponensekhez, adatokhoz férhessen
 hozzá például: névjegyzék, tárolók (SD kártya), kamera, stb.
 Minden engedélyt a felhasználónak kell jóváhagynia telepítéskor.
\end_layout

\begin_layout Subsubsection
AndroidManifest.xml
\end_layout

\begin_layout Standard
Az Android rendszer számára szükséges konfigurációs paramétereket, illetve
 az alkalmazás által használt komponensek deklarációját tartalmazza.
 Tartalmazza továbbá a felhasználói jogosultságok listáját, deklarálja az
 alkalmazás futtatásához szükséges minimum Android API szint számát, illetve
 egyéb hardver és szoftver paramétereket.
 Azok a komponensek, amik nincsenek deklarálva ebben a fájlban, nem láthatóak
 a rendszer számára.
 Ez a fájl az alkalmazás gyökérkönyvtárában foglal helyet.
\end_layout

\begin_layout Standard
Így néz ki egy Activity deklarációja a manifest fájlban:
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset External
	template JavaCode
	filename manifest.java

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Az <activity> elemben az android:name paraméter tartalmazza az Activity
 osztályból származó osztály nevét, melyet az alkalmazásban használunk.
 Az android:label paraméterben megadhatjuk a felhasználó számára megjelenő
 nevet.
\end_layout

\begin_layout Standard
A fenti példában látható <intent-filter> rész utasítja a rendszert, hogy
 a MainActivity nevű acvtivity objektumot töltse be az alkalmazás elindulása
 után.
\end_layout

\begin_layout Standard
Komponensek deklarációja a manifest fájlban a következők lehetnek:
\end_layout

\begin_layout Itemize
<activity> elemek az Activity-ból származó osztályokhoz
\end_layout

\begin_layout Itemize
<service> elemek a Service illetve IntentService típusú osztályokhoz
\end_layout

\begin_layout Itemize
<receiver> elemek a BroadcastReceiver osztályokhoz
\end_layout

\begin_layout Itemize
<provider> elemek a tartalomszolgáltató osztályokhoz
\end_layout

\begin_layout Subsubsection*
Adattárolás
\end_layout

\begin_layout Standard
Az Android számos lehetőséget kínál az adatok perzisztens tárolására.
 Ezek lehetnek megosztott preferenciák (Shared preference), mely primitív
 adatokat tárol kulcs-érték párok alapján, külső illetve belső tároló, illetve
 SQLite adatbázis.
 
\end_layout

\begin_layout Standard

\series bold
Megosztott preferenciák
\series default
 segítségével tárolhatjuk el egyszerűen az alkalmazás, illetve az egyes
 Activity objektumok állapotát, mivel az adatok megmaradnak az alkalmazás
 megszűnése után is.
 Kulcs-érték párok segítségével el tudjuk menteni az objektumok változóinak
 értékét, majd visszaolvasni, ha szükséges.
 Az eltárolt attribútumok float, int, long, boolean és string típusúak lehetnek.
 A 
\shape italic
getSharedPreferences()
\shape default
 metódus segítségével névvel ellátott preferenciát kapunk, melyet első paraméter
ként kell megadnunk, és arra hivatkozva bárhonnan el tudjuk érni az alkalmzásból.
 A 
\shape italic
getPreferences()
\shape default
 függvény segítségével az Activity objektumokhoz rendelhetünk egy preferenciát,
 amiben az adott tevékenység objektum adatait tárolhatjuk.
 
\end_layout

\begin_layout Standard

\series bold
Belső tár 
\series default
segítségével
\series bold
 
\series default
olyan fájlokat hozhatunk létre a telefonkészülék belső, nem hordozható memóriájá
ban, amikhez csak az alkalmazás férhet hozzá és annak eltávolításakor ezek
 a fájlok automatikusan törlődnek.
 
\end_layout

\begin_layout Standard
A 
\series bold
külső tár
\series default
 lehet a telefonhoz csatolt SD kártya, azaz hordozható memória egység, melyen
 olyan fájlokat tárolhatunk, melyekhez a felhasználó is hozzáférhet.
 
\end_layout

\begin_layout Standard
Android alkalmazásokban SQLite 
\series bold
adatbázisok
\series default
at hozhatunk létre, melyek név szerint minden komponensből elérhetőek, de
 más applikációból már nem.
 Az SQLite támogatja a hagyományos relációs adatbázis funkciókat, mint az
 SQL szintaxis és tranzakciók.
 A futás során az adatbázisnak kevés memóriára van szüksége (kb.
 250 KByte).
 Az adatbázisműveletek fájl műveleteket igényelnek, amik lassúak lehetnek,
 ezért aszinkron módon kell azokat végrehajtani.
 Adatbázis kezelés megvalósításához szükség lesz egy osztályra, mely az
 
\shape italic
SQLiteOpenHelper 
\shape default
osztályból származik.
 Ennek az 
\shape italic
onCreate() 
\shape default
függvényét kell felüldefiniálni az adatbázist létrehozó implementációval,
 melyet SQL paranccsal adhatunk meg.
 Az 
\shape italic
onUpgrade()
\shape default
 metódus felüldefiniálásával megadhatjuk hogy a programunk milyen utasításokat
 hajtson végre, ha a tábla korábbi verziója már létezik az adott eszközön.
 A helper osztályunk 
\shape italic
getReadableDatabase()
\shape default
 és a 
\shape italic
getWriteableDatabase()
\shape default
 függvényeinek segítségével kaphatunk egy SQLiteDatabase objektumot, melyen
 keresztül hozzáférhetünk az adatbázis táblákhoz és módosíthatjuk azokat.
 SQLiteDatabase 
\shape italic
query()
\shape default
 és 
\shape italic
rawquary()
\shape default
 metódusaival futtathatunk lekérdezéseket.
 Minden lekérdezés egy Cursor objektumot ad vissza, mely segítségével manőverezh
etünk a lekérdezés eredményének sorai között.
 
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset External
	template JavaCode
	filename test.java

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Hálózati protokollok a programban
\end_layout

\begin_layout Description

\series bold
UDP (User Datagram Protocol): 
\series default
kapcsolat nélküli, megbízhatatlan csomagtovábbítást nyújtó protokoll.
 Portszámot és checksum-ot is tartalmaz egy csomag.
 A csomagok nem biztos, hogy ugyanabban a sorrendben érkeznek meg a fogadóhoz,
 mint amilyen sorrendben el lettek küldve.
 A küldő nem kap visszaigazolást a csomag megérkezéséről.
 Ez a protokoll nagyon elterjedt a videojátékoknál és a telekommunikációban.
 
\end_layout

\begin_layout Description

\series bold
TCP (Transmission Control Protocol): 
\series default
megbízható de ezért lassabb is, mint például az UDP.
 Folyamként vagy fájlként kezeli a kapcsolatokat.
 A csomagok megfelelő sorrendjéről, illetve az elveszett csomagok újra küldésérő
l is gondoskodik.
 A csomagok pufferrelésével eléri, hogy az átviteli sebesség is közel állandó
 legyen az adat küldése, továbbítása során.
\end_layout

\begin_layout Description

\series bold
HTTP (Hypertext Transfer Protocol):
\series default
 a web hálózati protokollja, fájlok és más adatok - azaz erőforrások - továbbítá
sára használják.
 Ezek az erőforrások lehetnek HTML fájlok, képek, lekérdezési eredmények,
 stb.
 Használhat TCP és UDP protokollokat is.
 HTTP a kliens-szerver modellt használja, vagyis a HTTP kliens megnyitja
 a kapcsolatot és küld egy kérést a HTTP szervernek.
 Amint a szerver visszaküldte a választ lezárja a kapcsolatot.
 A HTTP üzenet felépítését tekintve egy kérés vagy válasz sorral kezdődik
 pl.: 
\begin_inset Quotes sld
\end_inset

GET /path/to/file/index.html HTTP/1.0
\begin_inset Quotes srd
\end_inset

 vagy 
\begin_inset Quotes sld
\end_inset

HTTP/1.0 200 OK
\begin_inset Quotes srd
\end_inset

.
 A GET HTTP metódussal kérhetünk el egy erőforrást a szervertől, további
 metódusok még a POST és a HEAD.
 Ez után az erőforrás neve, címe szerepel majd a HTTP verzió.
 Válasz esetében csak a HTTP verzió és a státusz kód szerepel.
 Ezek után szerepelhetnek paraméterek 
\begin_inset Quotes sld
\end_inset

PARAMÉTER: érték
\begin_inset Quotes srd
\end_inset

 alakban.
 Itt szerepelhet a szerver, illetve a kliens számra fontos információk,
 mint például az erőforrás módosításának ideje: 
\begin_inset Quotes sld
\end_inset

Last-Modified: Fri, 31 Dec 1999 23:59:59 GMT
\begin_inset Quotes srd
\end_inset

.
 Válasz üzenetek esetén a kért erőforrás az üzenet végén szerepel.
 Ebben az esetben a Paraméterek között szerepel az üzenet hossza és típusa.
 
\end_layout

\begin_layout Description
HTTP* egy specializált HTTP protokoll, melyet ebben a programban használok
 az Android applikáció és a szerveren futó alkalmazás kommunikációjában.
 A kommunikációt mindenképpen a mobil alkalmazás kezdeményezi egy "GET
\begin_inset Quotes srd
\end_inset

 üzenet küldésével, mely ilyen adatokat tartalmaz: GET / HTTP*/1.0
\backslash
n REPORTPERIOD: <jelentésküldés ideje>
\backslash
nMODE: <DL vagy UL>
\backslash
n CONNECTION: <TCP vagy UDP>
\backslash
n Unit: <1, 2 vagy 3>
\backslash
n BUFFERSIZE: <buffer méret>
\backslash
n.
 Ez az üzenet tartalmazza a teszt paramétereit, amiket a felhasználó adott
 meg.
 A szerver oldali program ezek alapján indítja el a megfelelő küldő vagy
 fogadó szálat.
 A program a teszt leállításakor egy 
\begin_inset Quotes sld
\end_inset

STOP
\begin_inset Quotes srd
\end_inset

 üzenetet küld a szervernek, mely ilyen alakú: "STOP / HTTP*/1.0
\backslash
n".
 Ennek hatására a szerver leállítja a teszt szálat.
\end_layout

\begin_layout Chapter
Felhasználói dokumentáció
\end_layout

\begin_layout Section
Program bemutatása
\end_layout

\begin_layout Standard
A Drive Testing applikáció egy Android készüléken futtatható program, mely
 a telefon hálózatról tud különféle statisztikai adatokat gyűjteni.
 Ehhez tartozik egy szerver oldali program is, mellyel a mobil alkalmazás
 a mérések során aktívan kommunikál.
 Az alkalmazással futtatható tesztek adatokat gyűjtenek a telefonhálózatról
 és a készülékről a szerver programmal történő kommunikáció során, melyek
 fontos információkkal szolgálhatnak a telefonhálózatot üzemeltető operátoroknak.
 A tesztelő akár menet közben, autóban ülve tudja a teszteket futtatni.
 A mérések során az adatok grafikus térképen is megtekinthetőek és a futtatás
 végeztével az eredmények ki is exportálhatóak az adatbázisból CSV formátumban
 egy tetszőleges fájlba.
\end_layout

\begin_layout Subsection
Program használatának feltételei
\end_layout

\begin_layout Standard

\series bold
Hardver feltételek
\end_layout

\begin_layout Standard
Az alkalmazás futtatásához szükséges egy legalább 4.0.4 verziójú Android operációs
 rendszerű telefonkészülék.
 Korábbi verziójú rendszeren lehetséges, hogy egyes funkciók nem működnek
 megfelelően, illetve el se indul a program.
\end_layout

\begin_layout Standard
A mobilkészüléken be kell kapcsolni a mobilhálózaton keresztüli adatelérést
 (Beállítások -> Vezeték nélküli és mobilhálózatok -> Mobilhálózatok ->
 Adatok engedélyezve jelölőnégyzetet kell bepipálni), illetve a GPS pozíció
 elérését a Helyszolgáltatások menüpontban a GPS-műholdak jelölőnégyzet
 segítségével aktiválhatjuk.
\end_layout

\begin_layout Standard
Szükséges továbbá egy asztali számítógép, melyen található JVM (Java virtuális
 gép) a szerver oldali program futtatásához.
 Ennek internet hozzáférést kell biztosítani.
\end_layout

\begin_layout Standard

\series bold
Szoftver feltételek:
\end_layout

\begin_layout Standard
A szerver oldali program fordításához és futtatásához szükséges a JDK (Java
 Developer Kit) legalább 1.6-os verziója, ami itt elérhető: [JDK]
\end_layout

\begin_layout Standard
Valamint az Apache ant, amit innen tölthetünk le: [ant].
 
\end_layout

\begin_layout Standard
A feltelepített Drive Test programban be kell állítani a szerver oldali
 számítógép IP címét, ha router illetve egyéb más hálózati eszköz is érintett
 a kommunikációban, úgy biztosítani kell, hogy az applikációk kommunikálni
 tudjanak a 4500-as porton keresztül.
 Továbbá a programok használhatják még az 5000, illetve a 5500 és 5600 közötti
 portokat a kommunikáció során.
\end_layout

\begin_layout Standard
Az alábbi lista tartalmazza a jogokat (permission), amit a mobilalkalmazás
 használ:
\end_layout

\begin_layout Description

\series bold
access coarse location:
\series medium
 az alkalmazásnak szüksége van erre ahhoz, hogy megjeleníthessük a készülék
 helyzetét a térképen és mérhessük a jelerősséget.
 Ezt a hálózati pozíciót gyorsan el tudja nekünk küldeni az adott hálózati
 eszköz, de elég durva becslést ad a telefon helyére vonatkozólag, körülbelül
 100 méteres pontossággal.
 Ezt akkor használjuk, amikor a GPS szolgáltatás nem elérhető, például beltérben.
\end_layout

\begin_layout Description

\series bold
access fine location (GPS):
\series default
 a szabadban megfelelően erős a GPS műhold jele ahhoz, hogy pontosan meghatározz
uk a telefon helyzetét, ehhez a szolgáltatáshoz szükséges ez a jogosultság.
\end_layout

\begin_layout Description

\series bold
internet, access network state, read phone state
\series default
: a hálózat állapotának figyelésével kapunk értesítést a jel erősség változásról.
 Internet hozzáférés szükséges a szerverrel való kommunikációhoz és a térkép
 frissítéséhez.
 A mérések során a telefon és a hálózat fontos paraméterei is rögzítésre
 kerülnek, kivéve a kritikus, azonosításra alkalmas paraméterek, mint például
 az IMEI/ESN szám, telefon szám, SIM széria szám vagy a MAC cím.
 Ezeket nem rögzíti az alkalmazás, csupán megjeleníti.
\end_layout

\begin_layout Description
read 
\series bold
and write external storage:
\series default
 külső tár írása és olvasása szükséges a jelentések, logok kiírásához.
 A felhesználó innen tudja lementeni a mérési eredményeket USB-n keresztül.
 
\end_layout

\begin_layout Section
Program használatának bemutatása
\end_layout

\begin_layout Subsection
Program telepítése
\end_layout

\begin_layout Subsubsection
Szerver oldali program futtatása
\end_layout

\begin_layout Standard
A program fordításához és futtatásához szükséges legalább a JDK 1.6 verziója.
 A 
\series bold
HttpServer
\series default
 mappában található ant 
\shape italic
build.xml 
\shape default
segítségével könnyedén fordíthatjuk és futtathatjuk az alkalmazást:
\end_layout

\begin_layout Description
- Egy tetszőleg terminálban menjünk a HttpServer könyvtárba.
\end_layout

\begin_layout Description
- Ezután az Apache ant program segítségével tudjuk fordítani az alkalmazást.
 Ezt a lépést csak egyszer kell végrehajtani, későbbiekben elég lesz csak
 a futtatásnál leírtakat elvégezni.
 A terminálban az 
\shape italic
ant
\shape default
 parancsot kell kiadni és a program fordítása elkezdődik.
\end_layout

\begin_layout Description
- Majd a sikeres fordítás végeztével az 
\shape italic
ant run 
\shape default
paranccsal futtathatjuk a programot.
\end_layout

\begin_layout Description
- A program indulása után ezt az üzenetet fogja látni:
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
d:
\backslash
HttpServer>ant run
\end_layout

\begin_layout Plain Layout
Buildfile: d:
\backslash
HttpServer
\backslash
build.xml
\end_layout

\begin_layout Plain Layout
run:
\end_layout

\begin_layout Plain Layout
[java] Log file: d:
\backslash
HttpServer
\backslash
server.log
\end_layout

\begin_layout Plain Layout
[java] Log fileWriter created
\end_layout

\begin_layout Plain Layout
[java] HTTP_Server: Waiting for connection on port:4500
\end_layout

\begin_layout Plain Layout
[java]
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Telepítés a mobileszközre
\end_layout

\begin_layout Standard
A telepítéshez szükséges a DriveTesting.apk fájl és hogy a mobilkészülék
 csatlakoztatva legyen a számítógéphez és hozzáférésünk legyen a telefon
 SD kártyájához.
 A telepítés menete:
\end_layout

\begin_layout Standard
1.
 A külső program telepítéséhez kell egy fájlkezelő program, mint a Total
 Commander vagy az Apps Installer nevű program, amivel tudunk manuálisan
 telepíteni.
 
\end_layout

\begin_layout Standard
2.
 Engedélyezni kell a telefonon az ismeretlen forrásból való telepítést.
 Ehhez menjünk a 
\begin_inset Quotes sld
\end_inset

Beállítások
\begin_inset Quotes srd
\end_inset

 menüben, ott válasszuk az 
\begin_inset Quotes sld
\end_inset

Biztonság" részt.
 Majd pipáljuk be az “Ismeretlen források” opciót.
 Ezek után már képesek leszünk külső programokat is telepíteni.
 
\begin_inset Wrap figure
lines 0
placement o
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Graphics
	filename telepites1.png
	lyxscale 60
	scale 60

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Telepítés
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement o
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Graphics
	filename telepit2.png
	lyxscale 80
	scale 80

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Program ikonja
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
3.
 Kapcsoljuk össze a telefont és a számítógépet USB kábellel.
 A telefonon az értesítési területen válasszuk ki az USB részt, és csatlakoztass
uk a memóriakártyát.
 Ekkor a telefon leválasztja az SD kártyát, és lehetővé teszi hogy a számítógépü
nkkel elérjük azt.
\end_layout

\begin_layout Standard
4.
 Másoljuk fel a programot egy tetszőleges mappába, majd válasszuk le az
 SD kártyát a PC-ről, és csatlakoztassuk a telefonon.
 Indítsuk el a fájlkezelő programot, és keressük meg a megfelelő fájlt.
 Válasszuk ki az apk fájlt, ekkor feljön egy opció, hogy megnyitjuk a fájlt,
 vagy telepítjük.
 Mi most az utóbbit válasszuk, az ablak a bal oldali képen látható.
 A következő ablakban átnézhetjük a program legfontosabb tulajdonságait,
 majd az 
\begin_inset Quotes sld
\end_inset

Telepítés
\begin_inset Quotes srd
\end_inset

 gombra kattintva telepíthetjük.
\end_layout

\begin_layout Standard
5.
 A sikeres telepítést követően az alkalmazások között megjelenik a program
 ikonja, mellyel futtathatjuk azt.
 Az ikon a bal alsó képen látható.
 
\end_layout

\begin_layout Standard
6.
 Az indítást követően meg kell adni a programnak a szerver gép publikus
 IP címét.
\end_layout

\begin_layout Subsection
Menü áttekintése
\end_layout

\begin_layout Standard
A felhasználó a menüpontok segítségével navigálhat az egyes ablakok között.
 Összesen öt ablakot tartalmaz az alkalmazás.
 Az applikáció minden ablakában négy menüelem kap helyet.
 
\end_layout

\begin_layout Standard
Széles telefon kijelző esetén - mint amilyennel egy tablet rendelkezik -
 az összes menüpont megjelenik a képernyő tetején az aktuális ablak nevével
 együtt.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename widephone.jpg
	lyxscale 70
	scale 80

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption

\begin_layout Plain Layout
Menü tablet-en (4.7
\begin_inset Quotes srd
\end_inset

, 1280 * 720)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Keskenyebb kijelző esetén a menüpontoknak csak az ikonja jelenik meg.
 
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename smallPhone.jpg

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Menü kis kijelzőn a készülék alján jelenik meg (4
\begin_inset Quotes srd
\end_inset

, 480*800 felbontás)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ikonok listája:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename mobil.png

\end_inset

- Main ablak 
\begin_inset Graphics
	filename test.png

\end_inset

- Test ablak 
\begin_inset Graphics
	filename m.png

\end_inset

- Térkép ablak
\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename export.png

\end_inset

- Export ablak 
\begin_inset Graphics
	filename setting.png

\end_inset

- Beálltások
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Ikonok
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Ablakok leírása
\end_layout

\begin_layout Subsubsection*
Main (fő) ablak
\end_layout

\begin_layout Standard
Az alkalmazás fő ablaka, ez jelenik meg az indítás után.
 A megjelenített lista két fő részre bontható: az első tartalmazza a telefon
 adatait (Phone Data), ezek nagy része nem változik, fontos paraméter a
 jel erősség érték (signal strength), ami a rádió hálózati torony által
 küldött jel erőssége.
 A második része a hálózati adatokat tartalmazza (Network Data).
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement o
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Graphics
	filename mainablak.png
	lyxscale 70
	scale 70

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Main ablak
\end_layout

\end_inset


\end_layout

\end_inset

Ezen adatok nagy része a telefon, illetve a hálózat aktuális állapotától
 függenek, mint például a hálózat típusa (Network Type), ami lehet UMTS,
 EDGE, stb.
 Ez a telefon helyétől függ és persze az adott területen elérhető mobilhálózat
 szolgáltatásoktól.
 A mérések szempontjából fontos adatok a már említett szignál erősség, hálózat
 típusa, ezeken kívül az MCC, MNC, LAC és a CID, ezen értékek változása
 esetén a képernyő automatikusan frissül a képernyőn is.
 Utóbbiak azonosítják a telefonoperátort az adott országra vonatkozóan,
 és meghatározzák a mobilkészülék helyét, azaz, hogy az operátor melyik
 cellájában tartózkodik.
 MNC (Mobile Network Code) és az MCC (Mobile Country Code) együtt egyértelműen
 meghatározza az operátort az adott országban, LAC (Location Area Code)
 a hálózat szolgáltatójához tartozó területi azonosító, CID (Cel ID) cella
 azonosító.
 A lista automatikusan frissűl, ha megváltozik egy érték.
 A felhasználó az ujja segítségével fel és le görgetheti a kijelzőn a táblázatot.
\end_layout

\begin_layout Subsubsection*
Test (teszt) ablak
\end_layout

\begin_layout Standard
Az alkalmazás fő része, ahonnan a felhasználó a teszteket tudja indítani.
 Egyszerre csak egy mérés futhat, és nem lehet menet közben megváltoztatni
 a beállításokat.
 A beállítások a következőek lehetnek: feltöltés vagy letöltés teszt, azon
 belül UDP vagy TCP protokollok használatát lehet beállítani rádiógombok
 segítségével.
 A megadott értékek, beállítások elmentődnek és az ablakok közti váltáskor
 megőrződnek, illetve visszatöltődnek, ha a felhasználó visszatér ehhez
 az ablakhoz.
 
\end_layout

\begin_layout Standard
A 
\begin_inset Quotes sld
\end_inset

Start test
\begin_inset Quotes sld
\end_inset

 feliratú gombra kattintva elkezdődik a teszt futtatás.
 Az előbb említett gomb beszürkül, ilyenkor nem fogadja a felhasználói események
et.
 A 
\begin_inset Quotes sld
\end_inset

Stop test
\begin_inset Quotes srd
\end_inset

 feliratú gomb kivilágosodik és fogadja a kattintás eseményét, ezzel lehet
 leállítani a futó tesztet.
 A teszt automatikusan leáll ha nem sikerül elindítani a tesztelést valamilyen
 beállítási vagy hálózati oknál fogva.
\begin_inset Wrap figure
lines 0
placement o
overhang 0col%
width "50col%"
status collapsed

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Graphics
	filename testablak.png
	lyxscale 70
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Test ablak
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
A teszt futtatásához szükséges paramétereket, a távoli szerver IP címét
 és a jelentés gyakoriságát módosíthatjuk a Settings (Beállitások) ablaknál.
\end_layout

\begin_layout Standard
A teszt futása során a felhasználó előre megadott intervallumonként jelentést
 kap, ami tartalmazza a mérések aktuális eredményét: hálózat típusát, a
 fel- és letöltési légsebességet, UDP teszt esetén a jittert és a fogadott
 és az elveszett csomagok számát.
 Ezt a riportot a képernyő közepén található lista tartalmazza.
 Ezt a listát törölheti a felhasználó, a 
\begin_inset Quotes sld
\end_inset

Clear logs
\begin_inset Quotes srd
\end_inset

 feliratú gombra kattintva.
 Az esetleges kapcsolati hibákról is ezen keresztül értesül a felhasználó.
 Ezen hibák a 
\begin_inset Quotes sld
\end_inset

Hibaüzenetek
\begin_inset Quotes srd
\end_inset

 fejezetben lesznek bővebben kifejtve.
 
\end_layout

\begin_layout Standard
Az aktuális tartalma ennek a log listának elmenthető a 
\begin_inset Quotes sld
\end_inset

Save logs
\begin_inset Quotes srd
\end_inset

 gomb segítségével.
 Az elmentett fájl neve az aktuális időbélyegből fog generálódni, például:
 201311031130.txt.
 A megadott beállításoknak megfelelően és a tárolók elérhetőségétől függően
 a külső vagy belső tárra fog elmentésre kerülni az applikáció könyvtárán
 belül.
\end_layout

\begin_layout Subsubsection*
Map (térkép) ablak
\end_layout

\begin_layout Standard
A térkép megjelenítéséhez szükséges mobil internet kapcsolat és GPS adat
 használat engedélyezés a pontos pozíció meghatározására.
 A felhasználó kiválaszthatja, hogy melyik teszt eredményeit szeretné látni
 a térképen megjelenítve.
 Erre szolgál a két oldalsó gomb: a "Set Test ID
\begin_inset Quotes srd
\end_inset

 és a 
\begin_inset Quotes sld
\end_inset

Set Test Name
\begin_inset Quotes srd
\end_inset

 gombok.
 A 
\begin_inset Quotes sld
\end_inset

Set Test ID
\begin_inset Quotes srd
\end_inset

 feliratú gombbal a felhasználó egy listából kiválaszthatja, hogy melyik
 teszt futást szeretné látni, annak azonosítója alapján.
 A 
\begin_inset Quotes sld
\end_inset

Set Test Name
\begin_inset Quotes srd
\end_inset

 gomb segítségével a teszt elnevezése alapján adhatja meg a látni kívánt
 tesztet.
 
\end_layout

\begin_layout Standard
Ha a felhasználó az 
\begin_inset Quotes sld
\end_inset

ALL
\begin_inset Quotes srd
\end_inset

 -t választja - akár test id-ként, akár test névként - a térképen az összes
 pont megjelenik és össze lesznek kötve úttal, akkor is ha valójában nem
 egy méréshez tartoztak.
 Ez megkönnyíti a pontok megkeresését a térképen.
 
\begin_inset Wrap figure
lines 0
placement o
overhang 0col%
width "50col%"
status open

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Graphics
	filename map.png
	lyxscale 70
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Térkép ablak
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ha éppen fut egy teszt, amikor ez az aktív képernyő, akkor a futó tesztre
 vonatkozó adatokat láthatja a felhasználó.
 Újabb jelentések érkezésekor a térkép frissül és az új mérések is láthatóak
 lesznek.
 
\end_layout

\begin_layout Standard
A térképen a színes pontok mérési pontokat jelölnek, a jelentés rögzítésének
 idejében az adott helyen volt a mobil készülék.
 Az egyes pontokra kattintva részletes információt kap a felhasználó egy
 felugró ablak segítségével.
 Ez tartalmazza többek között a jelerősséget, a le és feltöltési sebességet
 és a cella információkat.
 
\end_layout

\begin_layout Subsubsection*
Export ablak
\end_layout

\begin_layout Standard
Az ablak tetején található mezőbe írható be a kimeneti fájl neve.
 Ezt mindenképpen ki kell tölteni.
\end_layout

\begin_layout Standard
A program által generált teszteredmények fájlba menthetőek CSV formátumban.
 A CSV fájl első sora a fejléc: id, test_id, test_name, time, lat, lon,
 signal_strength, up_speed, down_speed, jitter, lost_packet, sum_packet,
 mcc, mnc, lac, cid, rate, network_type mezőkkel, ahol az id az adatbázis
 rekord azonosítója, a test_id a teszt futtatáskor generált teszt azonosító,
 test_name a teszt neve, amit a felhasználó a beállítások között adott meg,
 time a bejegyzés ideje, lat avagy latitude szélességi koordináta, a lon
 azaz longitude a hosszúsági koordinátája a mérés helyének, up_speed és
 a down_speed a fel- és letöltési sebesség, jitter-nek az UDP protokollt
 használó tesztek esetén van jelentősége és a csomagok közti késést mutatja,
 a lost_packet és sum_packet szintén UDP teszt esetén jelentős, az elveszett
 és az eddigi összes csomag számát jelentik, és a network type pedig a hálózat
 típusa (UMTS, EDGE, stb.), végül a rate a fel- és letöltési sebesség mértékegysé
gét jelölik (Mbits, Kbits, stb.).
 Az ez után lévő bejegyzések az adatbázis sorainak megfelelő adatok.
\end_layout

\begin_layout Standard
Lehetséges kiválasztani egy teszt ID-t, vagy teszt nevet, melyet ki akarunk
 exportálni, de akár az összes elemet is kiexportálhatjuk (ALL).
 Ezt a 
\begin_inset Quotes sld
\end_inset

Set Test ID
\begin_inset Quotes srd
\end_inset

 vagy a 
\begin_inset Quotes sld
\end_inset

Set Test Name
\begin_inset Quotes srd
\end_inset

 nevű gombra kattintva tehetjük meg.
 Rákattintva a felugró ablakból választhatjuk ki a megfelelő teszt azonosítót.
\begin_inset Wrap figure
lines 0
placement o
overhang 0col%
width "50col%"
status open

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Graphics
	filename exporting.png
	lyxscale 70
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Export ablak
\end_layout

\end_inset


\end_layout

\end_inset

Fontos megjegyezni, hogy csak a program adatbázisában található teszt azonosítók
 közül választhat a felhasználó.
 Ha még nem futtatott tesztet, akkor nem lesz bejegyzés és így exportálható
 adat sem.
 Továbbiakban meg kell adnunk a fájl nevét az 
\begin_inset Quotes sld
\end_inset

Output file name
\begin_inset Quotes srd
\end_inset

 szövegmezőben, mely a külső memória egységen lesz letárolva 
\begin_inset Quotes sld
\end_inset

sdcard/Android/com.drivetesting/files/export
\begin_inset Quotes srd
\end_inset

 illetve, ha ez nem lehetséges akkor az applikáció könyvtárában 
\begin_inset Quotes sld
\end_inset

data/data/com.drivetesting/export
\begin_inset Quotes srd
\end_inset

.
 Az 
\begin_inset Quotes sld
\end_inset

Export To CVS
\begin_inset Quotes srd
\end_inset

 feliratú gombra kattintva elkezdődik az adatok kimentése a megadott fájlba
 és megjelenik egy ablak 
\begin_inset Quotes sld
\end_inset

Exporting database...
\begin_inset Quotes srd
\end_inset

 felirattal.
 A dialógus ablakban forgó ikon jelzi, hogy még tart az exportálási folyamat.
\end_layout

\begin_layout Standard
A művelet befejeztével az ablak automatikusan bezáródik és egy felugró üzenetabl
akban megjelenik, hogy sikeres volt-e a művelet vagy sem.
 Sikeres exportálás esetén a fájl elérési útja is megjelenik.
\end_layout

\begin_layout Subsubsection*
Setting (beállítások) ablak
\end_layout

\begin_layout Standard
Az itt megjelenő paraméterek segítségével konfigurálható a teszt futtatás,
 illetve a program működése.
 Ezek a paraméterek a program bezárása után is megmaradnak, nem kell a felhaszná
lónak újra beállítania ezeket.
 
\end_layout

\begin_layout Standard
Teszt futtatásra vonatkozó paraméterek:
\end_layout

\begin_layout Itemize
Server IP address - szerver publikus IP címe
\end_layout

\begin_layout Itemize
Buffer size - egy-egy átküldött adatmennyiség mérete
\end_layout

\begin_layout Itemize
Report period - jelentés gyakoriságának ideje
\end_layout

\begin_layout Itemize
Test Name - teszt neve
\end_layout

\begin_layout Itemize
Units - sebesség és a fogadott adatok mennyiségének mértékegységét állíthatóak
 be
\end_layout

\begin_layout Subsection
Program használata és teszt futtatás
\end_layout

\begin_layout Standard
A fő ablakban is nyomon lehet követni a jel erősség, hálózat típusának és
 a cella információk változását, de ilyenkor nem kerül eltárolásra a változás,
 így nem lehet visszakövetni sem.
 A teszt ablakban van lehetőség tesztek futtatására.
 Választhatunk UDP és TCP protokollok, fel- és letöltés között a rádiógombok
 segítségével.
 A teszt futtatása előtt győződjön meg róla, hogy a szerver oldali program
 a HttpServer fut és elérhető a szerver és a fentebb említett portok szabadok.
 A szerver publikus IP címét be kell állítani a Beállítások menüpontban.
 A teszt futtatásához a 
\begin_inset Quotes sld
\end_inset

Start test
\begin_inset Quotes srd
\end_inset

 gombra kell kattintani.
 Ezután elindul az adatok fel vagy letöltése a beállításoknak megfelelően.
 A teszt addig fut amíg le nem állítják a 
\begin_inset Quotes sld
\end_inset

Stop test
\begin_inset Quotes srd
\end_inset

 feliratú gombbal.
 Az előre megadott időközönként (report intervallum) a program megvizsgálja
 és kiírja az aktuális értékeket az adatbázisba és megjelennek a 
\begin_inset Quotes sld
\end_inset

Messages
\begin_inset Quotes srd
\end_inset

 fejlécű listában a teszt ablakban.
 Ezek a bejegyzések tartalmazzák a különböző mérési eredményeket.
 A 
\begin_inset Quotes sld
\end_inset

Save logs
\begin_inset Quotes srd
\end_inset

 gomb segítségével elmenthető a Messages üzenet doboz aktuális tartalma.
 Az elmentett fájl neve és elérési útja egy felugróablakban lesz látható.
 A térképen látható az épp futó teszt és méréseknek megfelelően frissülnek
 az adatok rajta.
 Lehetőség van korábbi tesztek eredményeit is megjeleníteni a térképen teszt
 azonosító vagy teszt név alapján.
 Az export ablakban bármely tesztet ki lehet exportálni CSV formátumban
 az adatbázisból név vagy azonosító alapján.
 A fájl nevét is megadhatja a felhasználó és az export gomb megnyomásával
 elindul az exportálási folyamat.
 Végül egy felugró ablakban jelenik meg az elmentett fájl neve és elérési
 útja, illetve hiba esetén a hibaüzenet.
\end_layout

\begin_layout Subsection
Hibaüzenetek
\end_layout

\begin_layout Subsubsection*
Hibaüzenetek a teszt futtatás során
\end_layout

\begin_layout Itemize
GPS aktiválása szükséges a teszt futtatáshoz, ha ezt elmulasztja a felhasználó,
 akkor egy felugró ablak tájékoztatja erről, amikor a tesztet elindítaná
 a következő üzenettel: "GPS is not enabled.
 Do you want to go to settings menu?".
 A 
\begin_inset Quotes sld
\end_inset

Yes
\begin_inset Quotes srd
\end_inset

 gombra kattintva megjelenik telefon GPS-sel kapcsolatos beállításai, ahol
 aktiválni tudja a felhasználó ezt a szolgáltatást.
 A beállítás után a vissza gombbal a felhasználó visszatérhet a program
 tesztfuttatási ablakába.
\end_layout

\begin_layout Itemize
A mobilinternet aktiválása is szükséges a teszt futtatásához, ha ezt elmulasztja
 a felhasználó, akkor egy felugró ablak tájékoztatja erről, amikor a tesztet
 elindítaná a következő üzenettel: "Network is not enabled.
 Do you want to go to settings menu?".
 A 
\begin_inset Quotes sld
\end_inset

Yes
\begin_inset Quotes srd
\end_inset

 gombra kattintva megjelennek a telefon hálózattal kapcsolatos beállításai,
 ahol aktiválni tudja a felhasználó ezt a szolgáltatást.
 A beállítás után a vissza gombbal a felhasználó visszatérhet a program
 tesztfuttatási ablakába.
\end_layout

\begin_layout Itemize
Hibásan megadott szerver IP cím esetén a teszt futása hamar leáll és a következő
 üzenet olvasható a Teszt ablak üzenetei között: "Error: Cannot connect
 to server! IP: <megadott IP cím> port: 4500
\begin_inset Quotes srd
\end_inset

.
 Ilyen esetben a felhasználónak ellenőriznie kell a beállítások között a
 megadott IP cím helyességét, illetve, hogy elérhető-e egy külső hálózati
 eszközről.
 Ha a szerver nem közvetlenül kapcsolódik az internethez, akkor a hálózati
 eszközökben a PortForwarding funkció használatát és beállításait is érdemes
 ellenőrizni.
\end_layout

\begin_layout Itemize
Foglalt teszt port esetén a "Could not connect to server! Test port: <port
 szám>" üzenetet láthatja a felhasználó.
 Ez akkor történhet meg, ha egy másik program már használja az adott portot,
 ebben az esetben próbálkozzon új tesztet indítani, a teszt megpróbál egy
 másik portot használni.
 A szerver gépen az 5500 és 5600 közötti portokat használhatja teszt futtatásra
 a program.
 Minden teszt indításkor egy új portot fog választani a program.
 
\end_layout

\begin_layout Chapter
Fejlesztői dokumentáció
\end_layout

\begin_layout Section
A program architektúrája
\end_layout

\begin_layout Standard
A szerveroldali és a mobil alkalmazás is használja a 
\shape italic
HttpFileHandler.jar
\shape default
 fájlt, ami tartalmazza a közösen használt osztályokat.
 Ezen osztályok nagy része a tesztek futtatásában játszik szerepet.
\end_layout

\begin_layout Subsection
Közös osztályok architektúrája
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption

\begin_layout Plain Layout
HttpTestHandler osztályok
\end_layout

\end_inset


\begin_inset Graphics
	filename test.eps
	lyxscale 85
	scale 85

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Szerver oldal
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption

\begin_layout Plain Layout
HttpServer osztályai
\end_layout

\end_inset


\begin_inset Graphics
	filename server.eps
	lyxscale 85
	scale 85

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Kliens oldal
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption

\begin_layout Plain Layout
DriveTestApp osztályai 1.
 rész
\end_layout

\end_inset


\begin_inset Graphics
	filename mobilclass.eps
	lyxscale 90
	scale 80

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption

\begin_layout Plain Layout
DriveTestApp osztályai 2.
 rész
\end_layout

\end_inset


\begin_inset Graphics
	filename mobilclass2.eps
	lyxscale 90
	scale 80

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Adatbázis leírása
\end_layout

\begin_layout Standard
Az applikáció adatbázisa a mobileszközön ebben a fájlban tárolódik:
\end_layout

\begin_layout Standard
data/data/com.drivetesting/databases/drive_test_db_v1.
 
\end_layout

\begin_layout Standard
Az adatbázis, melyet drive_test_db_v1 hívnak egy test_data nevű adatbázis
 táblát tartalmaz.
 Ezek az attribútumai a táblának:
\end_layout

\begin_layout Itemize
"id" - integer típusú érték, a tábla elsődleges kulcsa, automatikusan implementá
lódik
\end_layout

\begin_layout Itemize
"test_id" - integer típusú érték, a teszt azonosítója
\end_layout

\begin_layout Itemize
"test_name" - varchar(100) típusú érték, a teszt nevét tartalmazza, amit
 a felhasználó a beállításoknál megadott
\end_layout

\begin_layout Itemize
"time" - varchar(100) típusú érték, a mérés pontos idejét tárolja
\end_layout

\begin_layout Itemize
"lat" - varchar(15) típusú érték, a mobilkészülék pozíciójának szélességi
 értékét tárolja
\end_layout

\begin_layout Itemize
"lon" - varchar(15) típusú érték, a mobilkészülék pozíciójának hosszúsági
 értékét tárolja
\end_layout

\begin_layout Itemize
"signal_strenght" - varchar(15) típusú érték, a jel erősség értékét tárolja
 dBm-ben
\end_layout

\begin_layout Itemize
"signal_level" - varchar(15) típusú érték, a jel erősség besorolását tartalmazza
 (0-4 közötti értéket vehet fel)
\end_layout

\begin_layout Itemize
"up_speed" - varchar(15) típusú érték, a feltöltési sebességet tárolja a
 rate által meghatározott mértékegységben
\end_layout

\begin_layout Itemize
"down_speed" - varchar(15) típusú érték, a letöltési sebességet tárolja
 a rate által meghatározott mértékegységben
\end_layout

\begin_layout Itemize
"jitter" - varchar(15) típusú érték, UDP tesztek esetén a jitter értékét
 tárolja
\end_layout

\begin_layout Itemize
"lost_packet" - integer típusú érték, UDP tesztek esetén az elveszett csomagok
 számát tárolja
\end_layout

\begin_layout Itemize
"sum_packet" - integer típusú érték, UDP tesztek esetén az eddig elküldött
 csomagok számát tárolja
\end_layout

\begin_layout Itemize
"mcc
\begin_inset Quotes srd
\end_inset

 - integer típusú érték, MCC azonosítója
\end_layout

\begin_layout Itemize
"mnc" - integer típusú érték, MNC azonosítója
\end_layout

\begin_layout Itemize
"lac" - integer típusú érték, LAC azonosítója
\end_layout

\begin_layout Itemize
"cid" - integer típusú érték, cella azonosítója
\end_layout

\begin_layout Itemize
"network_type" - varchar(15) típusú érték, a mobil hálózat típusát tartalmazza
\end_layout

\begin_layout Itemize
"rate" - integer típusú érték, az átviteli sebesség mértékegység azonosítóját
 tartalmazza
\end_layout

\begin_layout Subsection
Felhasználó felület, navigálás az ablakok között
\end_layout

\begin_layout Subsubsection
Felhasználói felület leírása
\end_layout

\begin_layout Standard
Az Android rendszerben az Activity objektumok rendelkeznek felhasználói
 felülettel, melyek leírását objektumonként külön-külön kell deklarálni
 XML fájlokban.
 Ezek a fájlok az alkalmazás könyvtárán belül a 
\shape italic

\begin_inset Quotes sld
\end_inset

res/layout
\begin_inset Quotes srd
\end_inset


\shape default
 könyvtárban találhatóak.
 Egy XML elem neve ebben az esetben egy Java objektum nevét tükrözi, tehát
 ha az XML elem egy <Button> elem, akkor az alkalmazás egy Button (gomb)
 objektumot fog létrehozni.
 Amikor betöltődik egy Activity objektum, akkor a neki megfelelő felület
 leíró XML fájlból a rendszer megfelelően létrehozza futási időben és inicializá
lja ezeket az objektumokat.
 
\end_layout

\begin_layout Standard
Példa egy egyszerű függőleges elrendezés egy szövegmezővel és egy gombbal:
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset External
	template JavaCode
	filename layout.java

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ezeket a leíró fájlokat könnyedén kézzel is szerkeszthetjük vagy akár az
 Eclipse fejlesztőeszközbe ágyazott grafikus szerkesztőfelület segítségével
 is.
 Különféle Layout objektumok segítségével meghatározhatjuk az egyes elemek
 (gombok, szövegmezők, stb.) elhelyezkedését.
 A felhasználóval való interakciókra különféle elemek állnak rendelkezésre
 pl.: gombok, beviteli mezők, dátumválasztók, stb.
 ezeket widget-eknek nevezzük.
 A felhasználói felületet (UI - user interface) leíró XML fájlokban hozzá
 tudunk rendelni különféle elemekhez visszahívó (callback) metódusokat.
 Ezeket az XML elemek android:on<valami> (pl.: android:onClick=<metódus_név>)
 paraméterében tudjuk meghatározni.
 A felhasználói felületet leíró fájlt használó Activity osztályban kell
 definiálni az XML elemekhez tartozó visszahívó metódusokat, melyek meghívódnak,
 ha az adott eseményt kiváltja egy felhasználói esemény.
 
\end_layout

\begin_layout Subsubsection
Menü leírása
\end_layout

\begin_layout Standard
A menüket külön XML leíró fájl(ok)ban definiálhatjuk, melyekben meg kell
 határozni az egyes menüpontokat.
 Ezen leíró fájlok a program könyvtárán belül a 
\begin_inset Quotes sld
\end_inset

res/menu
\begin_inset Quotes srd
\end_inset

 mappában találhatóak.
 A felhasználó a menün keresztül navigálhat a user interface-szel rendelkező
 Activity-k között és elérheti a beállításokat.
 Az Activity osztályokhoz az onCreateoptionMenu metódus megvalósításával
 tudunk menüt rendelni.
 Itt kell megadni, hogy mi történjen, ha a felhasználó az egyes menüpontokra
 kattint.
 Az Android rendszer automatikusan kirajzolja a menüt a képernyőre.
 A DriveTest mobilapplikáció minden Activity osztályból származó osztálya
 rendelkezik grafikus interfésszel és tartalmazza, felüldefiniálja a 
\shape italic
onCreateOptionsMenu
\shape default
 és a 
\shape italic
onOptionsItemSelected
\shape default
 metódusokat.
 Ezek segítségével lehet megjeleníteni a menüt és reagálni a menüt érintő
 felhasználói eseményekre.
 Az Android 3.0 verziójától a menü egy ActionBar-nak nevezett felületen jelenik
 meg, a menu.xml fájlban leírtaknak megfelelően.
 A leíró fájlban a menüelemek 
\shape italic
showAsAction
\shape default
 tulajdonságának állításával lehet befolyásolni azok megjelenését: ha 
\begin_inset Quotes sld
\end_inset

always
\begin_inset Quotes srd
\end_inset

 akkor mindig látható az adott elem, ha 
\begin_inset Quotes sld
\end_inset

ifRoom
\begin_inset Quotes srd
\end_inset

, akkor csak akkor jelenik meg az ActionBar-ban, ha elfér a telefon kijelzőjén.
 Az 
\begin_inset Quotes sld
\end_inset

always
\begin_inset Quotes srd
\end_inset

 opció esetén akkor is kirajzolódik a menüelem, ha nem fér ki az ActionBar-ban,
 ilyenkor a képernyő alján jelenik meg, ahogy az ActionBar bevezetése előtt
 is történt.
\end_layout

\begin_layout Section
A program megvalósítása
\end_layout

\begin_layout Subsection
Döntések a megvalósítás során
\end_layout

\begin_layout Standard
A fejlesztést megelőző kutatómunka során kiderült, hogy az android SDK nem
 támogatja számos hálózati berendezés és készülék információ elérését (biztonság
i okokból), így nem lehet egyszerűen az Android SDK segítségével úgy hívást
 kezdeményezni, hogy a hívás végeztével a hívásról adatokat kaphasson a
 program.
 Ehhez alacsony szinten, kernel szinten kellene hozzá férni az adatokhoz.
 Így a programban csak adathívásokra korlátozódik a tesztelés a tervezett
 hangívások helyett.
\end_layout

\begin_layout Standard
A program Java programozási nyelven készül, mert az Android is erre épül
 és könnyebb a szerverrel közös részek miatt mind a három részt Java alapokon
 megvalósítani.
 Ráadásul a Java készen ad sok programozást segítő könyvtárat, többek között
 a hálózati kommunikációhoz.
 Sajnos ebben az esetben a Java.net csomagban lévő osztályok egy nagy részét
 elfedik a hálózati kommunikációnak, így mikor egy Socket outputstream-jén
 keresztül egy üzenetet küldök a másik félnek, akkor csak bízni tudok benne,
 hogy a program valóban egyből kiküldi az üzenetet és nem végez semmiféle
 tömörítési, egyszerűsítési eljárást a csomagon, ami meghamisíthatná a mérési
 eredményeket és így a tesztek eredményeit is.
\end_layout

\begin_layout Standard
A hálózati forgalom mérésére, figyelésére használtam volna a TrafficStats
 osztályt, ez egy Android API által biztosított osztály, mely a hálózati
 forgalomról nyújt információkat a /proc/uid_stat/<uid> könyvtárból.
 Ez tartalmazza a TCP vagy UDP protokollokon küldött és fogadott byte-ok
 és csomagok számát.
 Ha a fájlok nem léteznek aTrafficStats nem tud hálózati statisztikával
 szolgálni.
 A getUidTxBytes() és a getUIDRxBytes() jelentések csak a TCP forgalmat
 tartalmazzák az UDP-re vonatkozót nem.
 Így az UDP forgalomról az alkalmazás nem kap semmilyen adatot.
 Ezen és hasonló hibák miatt, nem tudtam érdemben használni a küldött és
 fogadott csomagok mérésére.
 Ezért saját csomag figyelő és számoló algoritmust kellett írjak.
 
\end_layout

\begin_layout Subsection
Osztályok bemutatása
\end_layout

\begin_layout Subsubsection
Közös osztályok
\end_layout

\begin_layout Standard
A közösen használt és a teszteléssel összefüggő osztályokat a HttpTestHandler
 projekt tartalmazza.
 Ezen osztályok és interfészek tisztán Java alapúak, nem tartalmaznak Android
 specifikus megoldásokat, ezért használhatóak a szerver oldali programban
 is.
 
\end_layout

\begin_layout Description
ConnectionInstance megvalósítja a Java 
\shape italic
Callable 
\shape default
interfészt.
 Ez szolgál ősosztályként a TCP és UDP sender és receiver osztályoknak.
\end_layout

\begin_layout Description
HttpParser a HTTP* üzenetek feldolgozását végzi.
 A 
\shape italic
parseHttpMessage
\shape default
 metódusnak kell átadni az üzenetet és a függvény true (igaz) értékkel tér
 vissza, ha sikeres volt a feldolgozás.
 Egyébként az üzenet szintaktikai vagy szemantikai hibás, amitől nem tudja
 értelmezni a paraméterként kapott szöveget.
 A feldolgozott értékek Java 
\shape italic
Properties
\shape default
 típusú attribútumaiban tárolódnak.
 A 
\shape italic
methodProperty
\shape default
 tartalmazza az üzenet típusát, egy paramétert, ami a puffer méretét adja
 meg vagy egy azonosítót és a HTTP verziót.
 A 
\shape italic
headerProperty 
\shape default
pedig az opcionális paramétereket tartalmazza, ezek a tesztek paramétereit
 írja le: a 
\begin_inset Quotes sld
\end_inset

MODE
\begin_inset Quotes srd
\end_inset

 az adatforgalom irányát határozza meg, hogy a szerver küldi-e az adatokat
 (ez a letöltés, 
\begin_inset Quotes sld
\end_inset

DL
\begin_inset Quotes srd
\end_inset

), vagy a mobiltelefon (ez a feltöltés, 
\begin_inset Quotes sld
\end_inset

UL
\begin_inset Quotes srd
\end_inset

).
 A másik paraméter a 
\begin_inset Quotes sld
\end_inset

CONNECTION
\begin_inset Quotes srd
\end_inset

 a kapcsolat típusát határozza meg, miszerint UDP, vagy TCP protokollt fog
 használni a teszt.
\end_layout

\begin_layout Description
Logger osztály segítségével különféle üzeneteket menthetünk el egy fájlba.
 A programban főleg a hibaüzenetek eltárolásására használom, ami a hiba
 keresést könnyíti meg.
 Az üzenet a sztenderd kimenetre is kiíratható a 
\shape italic
addLineAndPrint 
\shape default
metódus segítségével.
 Ez utóbbit szerver oldali komponensben használható ki, mert ott a parancssorban
 is olvashatóak ezek az üzenetek.
 A log fájl nevét a konstruktorban adhatjuk meg, alapértelmezetten 
\begin_inset Quotes sld
\end_inset

log.txt" névvel fog létrejönni a fájl a bináris fájl mellett.
 Az addLine metódus hívásával az átadott szöveg ki fog íródni a fájlba és
 az elejére egy időbélyeg kerül.
\end_layout

\begin_layout Description
MessageI egy interfész, ami egyetlen sendReportMessage függvény fejlécét
 tartalmazza.
 Ennek segítségével tud a TCPSender és UDPSender osztály jelentéseket küldeni
 - a ReportSender osztályon keresztül - a teszt és a csomagok állapotáról
 a ReportReceiver osztály egy példányának.
\end_layout

\begin_layout Description
ReceiverReportI a ReportReceiver osztály interfésze, melyet jelentések küldésére
 használ.
 Külön metódus tartozik a TCP és UDP teszthez kapcsolódó jelentéshez.
 
\end_layout

\begin_layout Description
ReportI interfészt megvalósítja a HttpService osztály és segítségével tud
 a ReportReceiver osztály példánya üzenetet továbbítani, illetve küldeni
 a Test Activity felé a felhasználónak.
 A 
\shape italic
sendMessage
\shape default
 metódussal lehet üzenetet küldeni.
\end_layout

\begin_layout Description
ReportReceiver osztály példánya a mobilkészüléken fut - egy külön szálon
 - és fogadja a jelentéseket, riportokat, majd továbbítja a HttpService
 példánynak, ami továbbítja a TestActivity-nek az Application objektumon
 keresztül.
 Így láthatóvá válik és folyamatosan frissül a TestActivity üzenetlistája.
 A TCP- és UDPReceiver osztályoktól kapott értékek a 
\shape italic
ReceiverReportI
\shape default
 interfészen keresztül a 
\shape italic
setReceivedBytes 
\shape default
metódus segítségével továbbítódnak, ha a receiver (fogadó) osztálypéldányok
 a mobil alkalmazáson futnak - azaz a mobilkészülék a fogadó -, így a mobil
 letöltési sebességét vizsgáljuk.
 Egyébként a szerver által fogadott csomagokról a ReportSender osztálytól
 kap üzenetet, amit a 
\shape italic
receiveReport
\shape default
 függvényben található Scanner objektum vár és olvas be.
 A 
\shape italic
parseReport
\shape default
 és 
\shape italic
checkProperty 
\shape default
metódusok értelmezik a kapott üzenetet és küldenek jelentést a HttpService-nek
 a ReportI interfészen keresztül, ahogy a korábban említett 
\shape italic
setReceivedBytes 
\shape default
függvény
\shape italic
.
 
\shape default
A sebesség adatok is itt kerülnek kiszámolásra a 
\shape italic
calcSpeed
\shape default
 függvényben.
 
\end_layout

\begin_layout Description
ReportSender a szerver oldali programban fut az osztály egy példánya, külön
 szálon.
 A megadott porton létrehoz egy ServerSocket-et, ahova a kliens oldalon
 futó ReportReceiver osztálypéldánya tud csatlakozni.
 Ezen keresztül kap értesítést a kliens a szerver oldali csomagok érkezéséről,
 a teszt állapotáról.
 A 
\shape italic
sendReportMessage
\shape default
 függvény segítségével küld HTTP üzenetet, ami tartalmazza a jelentés paramétere
it.
 
\end_layout

\begin_layout Description
TCPReceiver fogadja a TCP típusú teszt során a TCP csomagokat és számolja
 a kapott üzeneteket, azok méretét és erről jelentést küld előre megadott
 időintervallumonként, ezt a 
\shape italic
setReportInterval
\shape default
 függvény segítségével lehet megadni.
 A 
\shape italic
TimerTask 
\shape default
osztály segítségével lehet meghatározni, hogy milyen művelet hajtódjon végre
 az időzítő lejártakor.
 Az időzítést a Timer osztály 
\shape italic
scheduleAtFixedRate
\shape default
 metódusával lehet megadni.
 Az osztály konstruktora képes MessageI és ReceiverReportI interfészeket
 fogadni attól függően, hogy szerver oldalon fut - így a ReportSenderen
 keresztül tud jelentést küldeni -, vagy a mobil oldalon, amikor a ReportReceive
r osztály példányát használja.
 A 
\shape italic
setSocket 
\shape default
segítségével állítható be a socket, amin keresztül érkeznek majd az adatok,
 üzenetek.
 A 
\shape italic
readPackets
\shape default
 végzi az üzenetek figyelését és kiolvassa az InputStream objektum segítségével
 a kapott adatokat.
 A 
\shape italic
totalReadedBytes
\shape default
 változó tartalmazza az eddig fogadott adatok mennyiségét byte-ban.
 A ConnectionInstance osztály leszármazottjaként tartalmaz egy stop metódust
 is, ami a teszt leállításakor hívódik meg és leállítja az időzítőt és a
 socket-et.
\end_layout

\begin_layout Description
TCPReport a TCP teszt mérési eredményeinek eltárolására szolgál.
 Tartalmazza: a reporter objektum azonosítóját, a jelentés intervallumát,
 az átvitt adatokat és a le- vagy feltöltési sebességet.
 tartalmaz egy parseReport függvényt, mely egy String objektumot elemez
 és feltölti a kiolvasott értékekkel a riport paramétereket.
 A jelentés paraméterek a 
\shape italic
toString 
\shape default
metódus felüldefiniálásával szöveggé konvertálhatóak.
 
\end_layout

\begin_layout Description
TCPSender a ConnectionInstance osztályból származik és a konstruktorában
 megadott méretű puffert tölt fel véletlenszerű adatokkal.
 A puffer adatát folyamatosan küldi a 
\shape italic
setSocket
\shape default
 függvényen keresztül megadott socket-en keresztül egy OutputStream objektum
 segítségével.
 A küldést addig folytatja, amíg a 
\shape italic
stop
\shape default
 metódusát meghívva le nem állítjuk, ami lezárja a socket objektumot.
\end_layout

\begin_layout Description
UDPReceiver fogadja a UDP típusú teszt során a csomagokat és számolja a
 kapott üzenetek méretét, figyeli a csomagok sorrendjét és az elveszett
 csomagokat is számolja.
 Erről jelentést küld előre megadott idő intervallumonként, ezt a 
\shape italic
reportInterval
\shape default
 paraméter lehet megadni az osztály konstruktorában.
 Az UDP protokollt használó tesztek során nem épül ki tartós kapcsolat a
 kliens és a szerver között, ezért nem kap Socket objektumot, hanem maga
 az UDP teszt osztály építi ki magának a kapcsolatot.
 Az UDP protokoll történő üzenetküldéshez a Java DatagramSocket és DatagramPacke
t osztályait használom.
 A mobilhálózatokban előforduló NAT-olás miatt a kommunikációt minden esetben
 a mobil oldali osztálynak kell kezdeményeznie, így nyitva egy portot, amin
 keresztül ezután a szerver képes üzenetet küldeni a mobilkészüléknek.
 A mobil oldalon való futtatáskor a 
\shape italic
setSenderParameters 
\shape default
metódust használom, ami megkapja a server IP címét, a teszt által használni
 kívánt port számot és létrehoz egy alapértelmezett Datagramsocketet.
 Ezt a szál 
\shape italic
start 
\shape default
metódusának meghívása elött kell meghívni.
 A 
\shape italic
start
\shape default
 meghívása után az osztály 
\shape italic
call 
\shape default
függvényébe kerül át a vezérlés, ami leellenőrzi, hogy be van-e állítva
 a 
\shape italic
senderAddress 
\shape default
paraméter - vagyis a szerver IP címe -, ha igen, akkor meghívja a 
\shape italic
sendAddressToSenderThroughNAT
\shape default
 függvényt.
 Ez arra szolgál, hogy küld egy DatagramPacketet a szerver címével és port
 számával a DatagramSoceket-en keresztül és vár egy válasz üzenetet.
 A riportolás a TCPReceiver-hez hasonlóan történik, annyi különbséggel,
 hogy itt több adatot küld át.
 Ezután a call metódus folyamatosan vár bufferSize méretü DatagramPacketeket.
 Számolja ezek sorszámát és fiegyeli az elveszett illetve rossz sorrendbe
 érkező csomagokat és számolja az aktuális jitter értéket a 
\shape italic
parsePackage
\shape default
 függvényben.
 A jitter érték számítás képletét az RFC 1889, Real Time Protocol (RTP)
 dokumentum tartalmazza.
 A 
\shape italic
lost
\shape default
 paraméter tartalmazza az elveszett, a 
\shape italic
cntOutofOrder
\shape default
 attribútum a felcserélődött csomagok számát tárolja, a 
\shape italic
sum
\shape default
 pedig az összes fogadott csomagszámát.
 
\end_layout

\begin_layout Description
UDPReport a TCPReport leszármazottja, mely tartalmazza a UDP tesztek sajátos
 paramétereit: az elveszett csomagok számát, a felcserélődött csomagok számát,
 az össz csomag számot és a jittert.
 Felüldefiniálja az ősosztályának metódusait, a 
\shape italic
parseReport
\shape default
 és a 
\shape italic
toString 
\shape default
függvényeket.
 Először meghívódik az ősosztály függvénye, majd az UDP specifikus attribútumok
 kezelése történik meg.
 
\end_layout

\begin_layout Description
UDPSender az UDPReceiver-hez hasonlóan megtalálható a 
\shape italic
setReceiverParameter 
\shape default
metódus, amelyből két példány is megtalálható különféle paraméterlistával.
 A mobil oldalon csak a port számot adjuk meg, ekkor a receiverAddress paraméter
 null értéket fog tartalmazni, ami azt jelenti, hogy a 
\shape italic
getAddressThroughNAT
\shape default
 metódus fog meghívódni a 
\shape italic
call 
\shape default
metódus futása során.
 A 
\shape italic
getAddressThroughNAT
\shape default
 fogadja a mobilkészüléktől az üzenetet és a beérkező DatagramPacket-ből
 kiolvassa a feladó címét és a portot, ahova majd az üzeneteket fogja küldeni.
 UDP protokoll nem garantálja a stabil adatátvitelisebességet sem, így ez
 megadható 
\shape italic
setRateInBitsPerSec
\shape default
 segítségével.
 Az 
\shape italic
initDelay
\shape default
 segítségével kiszámolódik, hogy mennyi időt kell várni a két csomag elküldése
 között ahhoz, hogy egységes adatrátát tudjon produkálni a teszt.
 A csomagküldés után ebből az időből levonódik a csomag elkészítésének ideje
 (paketization time) és ennyit vár a következő csomag küldése előtt, a JavaThrea
d osztályának 
\shape italic
sleep
\shape default
 metódusának segítségével várakoztathatjuk a szál futását.
 Minden csomag tartalmazza a csomag azonosítóját és elküldésének idejét.
 
\end_layout

\begin_layout Description
Utility osztály csak statikus függvényeket tartalmaz.
 Ezeknek kisegítő szerepe van.
 A 
\shape italic
decodePercent
\shape default
 metódust a HTTP üzenet feldolgozásánál használom, a 
\shape italic
fillStringBuffer
\shape default
 metódusok, pedig az átküldendő üzenetek elkészítésében játszanak szerepet.
 Véletlenszerű karakterekkel töltenek fel egy előre megadott méretű tömböt.
\end_layout

\begin_layout Subsubsection
Szerver oldal osztályai
\end_layout

\begin_layout Description
HttpServer a szerver oldali alkalmazás fő osztálya.
 Ez tartalmazza a 
\shape italic
main
\shape default
 metódust, ami az alkalmazás belépési pontja.
 Az indulása után létrehoz egy 
\shape italic
ServerSocket
\shape default
 objektumot és az előre definiált 4500 porton vár a kliens (mobilegység)
 csatlakozására.
 A ServerSocket accept metódusa blokkolja a futást, amíg nem kapcsolódik
 a kliens, amint ez megtörtént létrehoz egy új szálat (Thread), amiben a
 ServerThread osztály egy példánya fog futni.
 Jelen állapotában csak egy mobilt tud kiszolgálni az osztály, de könnyedén
 módosítható, hogy több eszközt is ki tudjon szolgálni.
\end_layout

\begin_layout Description
ServerThread osztály szolgálja ki a klienstől érkező kéréseket.
 A HttpServertől kapott socket-en keresztül fognak érkezni a klienstől a
 kérések, ezek kezelésére kell egy Scanner objektum, amit a konstruktorban
 hozok létre a socket 
\shape italic
getInputStream()
\shape default
 metódusának segítségével.
 A válaszok küldésére egy PrintWriter objektumot használok.
 A Java
\shape italic
Thread
\shape default
 (szál) osztályának leszármazottjaként megörökli a 
\shape italic
run
\shape default
 metódust, amit felüldefiniál.
 Az ott leírt parancsok futnak a szál objektumon meghívott 
\shape italic
start 
\shape default
függvény után.
 Az osztály a konstruktorában hívja meg saját magára a start függvényt.
 A kliens és a szerver HTTP*/1.0 protokol alapján kommunikálnak egymással.
 A kliens kezdeményezi a kommunikációt, így a 
\shape italic
run 
\shape default
metódus kezdetén megvárom a kliens üzenetét.
 Minden üzenetnek 
\begin_inset Quotes sld
\end_inset


\backslash
nEND"-del kell végződnie, addig fűzi össze soronként a klienstől kapott
 üzeneteket.
 Ezután a 
\shape italic
HttpParser
\shape default
 osztály 
\shape italic
parseHttpMessage 
\shape default
függvényének segítségével értelmezi a program az üzenetet.
 Két féle üzenetet fogad a szerver: az egyik a 
\begin_inset Quotes sld
\end_inset

GET
\begin_inset Quotes srd
\end_inset

 a másik pedig a 
\begin_inset Quotes sld
\end_inset

STOP
\begin_inset Quotes srd
\end_inset

, minden más esetben hibaüzenetet küld vissza a kliensnek válaszul.
 Az válaszüzenetet a 
\shape italic
sendResponse 
\shape default
metódus segítségével küldi ki az applikáció.
 GET üzenet esetén létrehozunk egy ServerSocketet-et a következő szabad
 portszámmal - ez 5500 és 5600 között vehet fel értéket- és 5 másodpercig
 vár, hogy a kliens oldalon indított teszt csatlakozzon hozzá, ezután a
 
\shape italic
makeTestHandlingThread
\shape default
 metódus ellenőrzi a kapott paramétereket és küld választ a kliensnek, mely
 tartalmazza a test port számát.
 Hiba esetén error üzenetet küld vissza a kliensnek.
 A kliens csatlakozása után inicializálódik a ReportSender objektum, későbbiekbe
n ezen keresztül tud jelentést küldeni a tesztről az applikáció.
 Végül a beállításoknak megfelelően létrejön és inicializálódik a megfelelő
 teszt osztály, amit egy 
\shape italic
ExecutorService
\shape default
 objektumban tárolunk, mely segítségével visszajelzést kaphatunk az aszinkron
 futó szálak befejeződéséről és visszatérési értékükről.
 A ExecutorService 
\shape italic
pool
\shape default
 metódusának hívásakor a szál futása is elkezdődik.
 
\begin_inset Quotes sld
\end_inset

STOP
\begin_inset Quotes srd
\end_inset

 típusú üzenet akkor érkezik, mikor a felhasználó leállítja a tesztfuttatást.
 Ilyenkor az összes futó szál 
\shape italic
stop
\shape default
 metódusa meghívódik és leáll a futásuk, beleértve a 
\shape italic
report
\shape default
 osztályt is.
 
\end_layout

\begin_layout Subsubsection
Mobil alkalmazás osztályai
\end_layout

\begin_layout Description
DataStorage az adatbázis kezelésére szolgáló osztály.
 Ezen osztály metódusai segítségével hajthatunk végre módosításkot, lekérdezések
et az adatbázisban.
 Az open metódus meghívásával létrejön a tényleges adatbázis, ezután lehet
 új rekordokat felvinni és módosítani azokat az adatbázisban.
 Ezt a metódust csak egyszer kell meghívni az applikáció indulásakor.
 A 
\shape italic
db 
\shape default
változó reprezentálja az SQLite adatbázist, és az 
\shape italic
open 
\shape default
metódus meghívásakor kap értéket a DbHelper 
\shape italic
getWritableDatabase 
\shape default
metódusának segítségével.
 Az 
\shape italic
insert
\shape default
 metódus segítségével tudunk egy új elemet, rekordot felvinni az adatbázisba,
 paraméterlistájában a rekord összes paraméterét meg kell adni.
 A különféle query (lekérdezés) kezdetű metódusokkal lekérdezéseket futtathatunk
, melyek visszatérési értéke egy String vagy DbData típusú objektumokat
 tartalmazó lista.
 A 
\shape italic
queryAll
\shape default
 metódussal az adattábla összes elemét lekérdezhetjük, a 
\shape italic
querySpecifiedTest és a querySpecifiedTestByName
\shape default
 metódussal egy meghatározott azonosítójú, illetve nevű elemet kérdezhetünk
 le.
 A cursorToData nevű private függvény segítségével alakítja át az osztály
 a lekérdezés eredményeit - amik Cursor típusú elemek - DbData típusúvá.
 Így egységesen és könnyen kezelhetőek lesznek a lekérdezések kimenetei.
\end_layout

\begin_layout Description
DbHelper osztály az Android SQLiteOpenHelper osztályából származik, mely
 segítségével lehet létrehozni az adatbázist.
 A programban az 
\shape italic
onCreate 
\shape default
metódus lefutásakor egy SQL művelet segítségével hozzuk létre a megfelelő
 attribútumokkal rendelkező adatbázistáblát.
 Az onUpgrade metódus segítségével lehet egy korábbi verziójú adatbázistáblát
 frissíteni egy újabbra, aminek például több vagy kevesebb attribútuma van.
 A program ilyen esetben csak törli a korábbit és létrehozza az újat.
 Ezek a műveletek tranzakciókban hajtódnak végre, ami biztosítja, hogy egy
 hiba esetén a program visszaáll a korábbi állapotra, táblára, így biztosítva
 az adatok sértetlenségét.
\end_layout

\begin_layout Description
DbData struktúra tartalmazza egy adatbázis elem paramétereit.
 Konstruktorában ezek inicializálódnak.
 Az egyes paraméterek publikus hozzáférésűek, így az osztályon kívülről
 szabadon állíthatóak ezek értékei.
 A 
\shape italic
toString
\shape default
 metódus szöveges kimenetet állít elő az attribútumokból.
 A 
\shape italic
toDescriptionString 
\shape default
pedig a OSMActivityben használt mérési pontokon megjelenő szöveget generálja
 ki az adott parméterekből.
\end_layout

\begin_layout Description
DriveTestApp az Android Application osztály leszármazottja és a LocationSubject,
 a PhoneStateSubject és a TestSubject interfészt valósítja meg.
 Az interfészek az Observer tervezési mintának megfelelő elemek, így az
 Observer (megfigyelő) objektumok beregisztrálhatják magukat és a releváns
 adat(ok) változásáról értesítést kapnak.
 Ezen osztály objektuma indul el legelöszőr a program indítása során.
 Azon paraméterek tárolódnak itt, melyeket több Activity is használ, általában
 az információ áramlást, cserét segítik ezek a tárolt adatok.
 Itt történik az adatbázis létrehozása és írása és azokat az adatokat, melyek
 nem a mérésből származnak (hálózat típusa, jel erőssége, stb) is itt tárolódnak
 el.
 Továbbá eltárolódik a mobilinternet és a GPS használatának be- vagy kikapcsolt
 állapota, ami a teszt futtatása előtt ellenőrzésre kerül.
 Ezen információkat a megfelelő szolgáltatások adják, a PhoneStateListenerServic
e a mobilkészülék adatainak és a telefon állapotának változásairól értesít,
 míg a GPSService szolgáltatás a GPS pozíció értékét frissíti.
 Ezen szolgáltatásokat az Application objektum indítja el és a hozzájuk
 tartozó adatokat, attribútumokat is ez kezeli.
 A DriveTestApp objektum értesül a változásokról a szolgáltatásoktól és
 értesíti a beregisztrált megfigyelő objektumokat.
 Itt található a prefs változó is mely egy SharedPreferences típusú változó.
 Ez tárolja a Beállítások menüben beállított értékeket és a prefrences.xml
 tartalmazza a beállítható paramétereket és a menü leírását is.
 Tartalmaz egy Handler típusú változót mely fogadja a HttpService-től érkező
 üzeneteket.
 Ezen keresztül továbbítódnak a jelentések a tesztek futása során és itt
 íródnak ki adatbázisba a jelentések a 
\shape italic
storeUDPReportItem
\shape default
, illetve a 
\shape italic
storeTCPReportItem
\shape default
 metódusok segítségével.
 A 
\shape italic
startHttpClientService 
\shape default
függvény indítja el a HttpService szolgáltatást, ami fontos szerepet játszik
 a tesztek futtatásában.
 A szolgáltatás indításakor átadja a szükséges paramétereket egy Intent
 objektumba ágyazva.
 A szolgáltatás indítása a 
\shape italic
startService 
\shape default
metódus segítségével történik.
 A teszt futását és a szolgáltatást is a 
\shape italic
stopHttpClientService 
\shape default
meghívásával lehet leállítani.
 Tartalmaz továbbá lekérdező metódusokat, melyek a DataStorage típusú változón
 kerülnek végrehajtásra.
\end_layout

\begin_layout Description

\series bold
Export Activity
\series default
 A program által generált teszt eredények fájlba menthetőek CSV formátumban
 ennek az Activity-nek a segítségével.
 A 
\begin_inset Quotes sld
\end_inset

Set Test Id
\begin_inset Quotes srd
\end_inset

 gombra kattintva a 
\shape italic
onTestClick 
\shape default
visszahívó metódus hívódik meg, ami megjeleníti a test azonosító választó
 felugróablakot.
 A test id-kat az adatbázisból kérdezi le a program majd egy AlarmDialog-on
 keresztűl megjeleníti azokat.
 A 
\begin_inset Quotes sld
\end_inset

Export to CVS
\begin_inset Quotes srd
\end_inset

 feliratú gombra kattintva a 
\shape italic
onExportClick 
\shape default
metódus hajtódik végre, ahol leellenőrzi a program a beállított paramétereket,
 ha valamelyik nincs beállítva, akkor hibát jelez AlarmDialog segítségével.
 Az adatok a FileHandler osztály segítségével íródnak ki a külső vagy belső
 tárra.
 Ha elérhető (írásra is) a külső tár, akkor oda fog kerülni a fájl, különben
 a belső tárra.
 Az exportálás a fájlművelet miatt aszinkron folyamat, ami az AsyncTask
 osztály segítségével lett megvalósítva.
 Ez az aszinkron osztály a ExportToCVS, ez felelős a fájl kiírásáért, ami
 a 
\shape italic
doInBackground
\shape default
 metódusban lett megvalósítva, itt kerül meghívásra a FileHandler osztály
 példányának megfelelő kiíró függvénye.
\end_layout

\begin_layout Description
FileHandler osztály tartalmazza a fájl kezelési függvényeket, amik segítik
 az írás és olvasási műveleteket a külső vagy belső tárokon.
 A paraméterek segítségével megadható a célkönyvtár és a fájl neve ami tartalmaz
ni fogja a kiírt infomrációkat vagy ahonnan az olvasás fog történni.
 Az interfészen megadható a külső vagy belső tárat szeretnénk használni
 és a program automatikusan megvizsgálja, hogy elérhető-e a külső tár vagy
 sem.
 Utóbbi esetben a program mindenképpen a belső tárra fog írni és onnan próbál
 meg olvasni is.
 Ezt a logikát a 
\shape italic
writeFile
\shape default
 és a 
\shape italic
readFile
\shape default
 metódusok tartalmazzák, maga a külső tár elérhetőségének vizsgálata az
 
\shape italic
init
\shape default
 függvényben történik meg.
\end_layout

\begin_layout Description
GPSService szolgáltatás az Android Service osztályból öröklődik és megvalósítja
 a LocationListener interfészt.
 A szolgáltatás indításakor az Application objektumban beállítódik, hogy
 fut a GPS szolgáltatás, majd az 
\shape italic
onStartCommand
\shape default
 metóduson keresztül meghívódik a 
\shape italic
getLocation
\shape default
 függvény, ahol beregisztrálódik a GPSService osztály, mint LocationListener
 és így kap értesítést, ha változik a GPS pozíció, illetve, ha a szolgáltatás
 álllapotának változásáról is.
 Ehhez meghívom a LocationManager Android osztály 
\shape italic
requestLocationUpdates
\shape default
 metódusát és utolsó paraméterként átadom a GPSService példányra mutató
 this pointert.
 A GPS koordináta változásakor a 
\shape italic
onLocationChanged
\shape default
 visszahívó metódussal kap értesítést a szolgáltatás.
 Ekkor a kapott Location paramétert továbbítja a DriveTestApp objektum felé.
 Az osztály megszűnésekor leiratkozik a pozíció frissítési szolgáltatásról.
\end_layout

\begin_layout Description
HttpService Az alkalamazás egyik kulcs osztálya, nagy szerepe van a teszt
 futtatás során.
 A 
\shape italic
IntentService 
\shape default
osztályból származik, mely olyan szolgáltatás, ami csak addig fut amíg az
 
\shape italic
onHandleInstance
\shape default
 metódusában leírtak végrehajtódnak.
 Ez az osztály kezeli a szerveroldali ServerThread osztályhoz hasonlóan
 a teszt futtatásában aktívan részt vevő osztályok példányosítását és a
 szálkezelést is.
 A Messenger osztály segítségével tud kommunikálni a TestActivity példányával
 a 
\shape italic
sendMessage
\shape default
 függvény segítségével tud annak üzenetet küldeni.
 Ezt a Messenger objektumot az 
\shape italic
onHandleInstance
\shape default
 metódusban kapja meg az osztály az Intent típusú paraméteren keresztül,
 akárcsak a többi teszt futtatáshoz szükséges paramétert mint az adatáramlás
 iránya, protokoll típusa és a buffer mérete.
 Ebben a fügvényben csatlakozik a mobilkészülék a szerverhez az előre definiált
 4500-as porton keresztül.
 Ez a program futása során csak egyszer történik meg.
 Ezután meghívódik a 
\shape italic
makeNewThread 
\shape default
nevű függvény, ahol elkezdődik a kommunikáció a serverrel HTTP*/1.0 típusú
 üzenetek segítségével.
 Itt beszéli meg a készülék a szerverrel a teszt paramétereit, majd létrejönnek
 a teszt futtatáshoz szükséges TCP vagy UDP osztály és elindul egy külön
 szálon a reportReceiver is, ami a jelentéseket fogadja.
 A 
\shape italic
sendMessageToServer
\shape default
 metódussal tud üzenetet küldeni a szerver felé, a 
\shape italic
receiveMessageFromServer
\shape default
 függvényben pedig vár egy üzenetet a szervertől és értelmezi azt a 
\shape italic
parseServerAnswer
\shape default
 metódus segítségével.
 Az onDestroy eseményt a szolgáltatás leállítása váltja ki, ekkor a 
\shape italic
stop
\shape default
 metódusának segítségével leállítódnak a teszt szálak is.
\end_layout

\begin_layout Description
MainActivity Az alkalmazás fő (main) activity objektuma, vagyis ez az objektum
 töltődik be az alkalmazás indulásakor és az ehhez tartozó felület fog megjelenn
i a képernyőn.
 A képernyőn megjelenő paraméter lista két fő részből tevődik össze.
 A telefon adataiból - ezek nagyrészt statikus adatok -, melyeket egyszer
 kérdez le az osztály a TelephonyManager segítségével, ezek a phoneDataList
 változóban tárolódnak.
 A másik rész pedig a mobil hálózatra vonatkozó információk, melyek dinamikusan
 változhatnak, ezen információkat a networkDataList változó tartalmazza.
 Ezek értékeit a PhonestateListenerService-től kapja az osztály.
 Ehhez megvalósítja a PhoneStateObserver interfészt és beregisztrálja magát
 az application objektumba, mint observer (megfigyelő) objektum: 
\begin_inset Quotes sld
\end_inset

((DriveTestApp)getApplication()).
 registerPhoneStateObserver(this);" A SimpleAdapter segítségével lehet táblázato
s formába rendezni az adatokat, ehhez szükséges egy layout xml fájl, ami
 leírja az elrendezést.
 A két listához tartozó adapter neve phoneDataAdapter és networkDataAdapter.
 A 
\shape italic
setHashMapElement 
\shape default
metódus használatával adhatunk hozzá elemet a listákhoz, illetve módosíthatjuk
 egy bejegyzés értékét.
 A módosítást követően az adapter objektum 
\shape italic
notifyDataSetChanged
\shape default
 metódusával frissíthetjük a kijelzőn megjelenő listát.
 A SeparatedListAdapter segédosztály segítségével jeleníthetjük meg ezeket
 a listákat fejléccel, összefűzve.
 Ennek segítségével rendelhetünk különböző színt a lista soraihoz.
 Az osztály 
\shape italic
OnCreate 
\shape default
metódusában inicializálódnak a lista attribútumok az 
\shape italic
initPhoneData
\shape default
, illetve az 
\shape italic
initNetworkData
\shape default
 függvények segítségével.
 A TelephonyManager segítségével kiolvassuk a megfelelő értéket az állandó
 paraméterekhez, a változó értékekhez 
\begin_inset Quotes sld
\end_inset

-
\begin_inset Quotes srd
\end_inset

 jel íródik be, mely rögtön megváltozik, ha az adott paramétert érintő változás
 következik be.
 Az osztály OnPause esemény bekövetkeztekor a removePhoneStateObserver metódus
 segítségével kitörölteti magát a PhoneStateObeserverek listájáról.
 Ez az esemény akkor következik, be mikor a felhasználó másik activity-re
 vált át vagy bezárja az applikációt.
 Az OnResume esemény következik be, amint újra ez az activity kerül előtérbe.
 Iyenkor beregisztrálódik újra a PhoneStateObeserverek listájára és értesítést
 kap az értékek változásokról.
\end_layout

\begin_layout Description
OSMActivity főfeladata a térkép és azon a kiválasztott mérési pontok megjeleníté
se.
 A TestObserver interfészt megvalósítja, mivel így kap értesítést az újabb
 teszt bejegyzések érkezéséről, amit lekér az adatbázisból a 
\shape italic
queryLastInsertedRow
\shape default
 függvény segítségével és megjelenít a térképen.
 Ehhez az 
\shape italic
update
\shape default
 metódust kellett felüldefiniálni.
 A térkép megjelenítéséhez és kezeléséhez egy külső könyvtárat használok
 osmdroid-ot.
 Ez egy szabadon felhasnzálható könyvtár, mely a Google Maps-hoz hasonló
 szolgáltatásokat nyújt ingyenesen.
 Ennek segítségével tudom megjeleníteni a térképet és rajta az útvonalat
 és a jelentéseket reprezentáló elemeket.
 Az onCreate eseménykor inicializálódnak a paraméterek, mint például a mapView,
 ami a térképnézetet reprezentálja és a controller változó, ami IMapController
 típusú és többek között ezen keresztül lehet a nagyitást (zoom) állítani.
 Az onPause eseménykor elmentésre kerül az aktuális pozíció, a nagyítás
 értéke és a beállított teszt azonosító, illetve teszt név is.
 Ezek az információk az onResume eseménykor, vagyis mikor újra aktív lesz
 ez az ablak, visszatöltődnek és beállítódnak.
 A teszt azonosítót a 
\begin_inset Quotes sld
\end_inset

Set Test Id
\begin_inset Quotes srd
\end_inset

 feliratú gombra kattintva állíthatja be a felhasználó, ennek megnyomásakor
 a 
\shape italic
onTestClick
\shape default
 függvény fog meghívódni.
 Ha a teszt nevét választja ki a felhasználó, akkor a 
\begin_inset Quotes sld
\end_inset

Set Test Name
\begin_inset Quotes srd
\end_inset

 feliratú gombra kattintva a 
\shape italic
onTestNameClick 
\shape default
metódus fog végrehajtódni.
 A szövges mezőben megjelenik a kiválasztott érték, a megadott teszt azonosító
 vagy a teszt neve.
 A teszt név több teszt futást is tartalmazhat, különféle teszt azonosítójú
 teszteket foghat össze.
 Ilyenkor a térképen a különbözö tesztek végpontjai is össze lesznek kötve
 egymással.
 A 
\shape italic
loadRoad
\shape default
 metódus hívódik meg egy teszt betöltésekor és egy új elem hozzáadásakor
 is.
 Az itt szereplő nodeA és nodeB változók két egymást követő mérési pontot
 jelölnek a térképen.
 Ezek RoadNode típusú objektumok, ami tartalmazza a pont helyét a térképen
 (szélességi és hosszúsági fokot) és szövegesen a mérési adatokat.
 A 
\shape italic
addRoadNode
\shape default
 metódus segítségével készít a program RoadNode típusú objektumokat az egyes
 adatbázis rekordokból.
 A noOfPoints változó tartalmazza, hogy eddig összesen hány darab pont van
 betöltve a térképen, illetve a nodeCount változó meghatározza hogy még
 hány pontot kell betölteni.
 Maga az út rajzolás és számolás kötelezően AsyncTask típusú objektumban
 kell hogy történjen, hogy ne akadályozza a fő szál futását, így ezt az
 UpdateRoadTask belső osztály végzi.
 A roadManager 
\shape italic
getRoad
\shape default
 metódusa kiszámítja az utat a két megadott végpont között és visszatér
 egy Road típusú elemmel.
 Az 
\shape italic
drawRoadOnMap
\shape default
 metódus rajzolja a térképre a kiszámolt útszakaszt a PathOverlay típus
 segítségével, ami a RoadManager 
\shape italic
buildRoadOverlay
\shape default
 függvényének eredménye.
 Itt korrigálódik a mérési pont helye, hogy illeszkedjen az útra és kirajzolódik
 a mérési pontot reprezentáló jel is.
 A jel színe a jel erősségétől függően 5 féle lehet.
 Ha van még kirajzolandó pont, akkor újra meghívódik a loadRoad függvény,
 egyéb esetben pedig a setOverlays hívódik meg, ami az utolsó betöltött
 pontot helyezi a középpontba és garantálja hogy az egyes rétegek megfelelő
 sorrendben kerüljenek kirajzolásra, végül újra rajzoltatja a térképet az
 
\shape italic
invalidate
\shape default
 metódus hívással.
 
\end_layout

\begin_layout Description
PhoneStateListenerService Az Android API által nyújtott dinamikus, időben
 változó telefon és hálózati információk lekérdezésére vonatkozó szolgáltatásoka
t valósítom meg itt.
 A 
\shape italic
connectivityReceiver
\shape default
 egy BroadcastReceiver, minek segítségével a ConnectivityManager üzeneteit
 megkapja az alkalmazás és így figyelhető a mobil internet szolgáltatás
 elérhetősége.
 A változásról értesül az application objektum is.
 A készülék és a hálózat adatairól a TelephonyManager segítségével kaphatunk
 információkat.
 PhoneStateListenerImpl segédosztály megvalósítja a PhoneStateListener interfész
t, így kap értesítést az applikáció az adatkapcsolat (data connection) állapotár
ól és a pozícióhoz kapcsoló MCC, MNC, LAC és CID paraméterekről is.
 Ezek az értékek az application objektumban lesznek letárolva.
 A PhoneStateListener a ConnectivityReceiverrel egyetemben a service konstruktor
ába kerül beregisztrálásra.
 A jelerősség értéket osztályozom a GSM sztenderdnek megfelelően (TS 27.007,
 8.5 fejezet) ASU (Arbitrary Strength Unit) értékek 0-tól 3-ig terjednek,
 ahol a 31 a kiváló minőséget jelöli, ezen értékek átszámíthatóak dBm-be
 és a jel erősség paraméter ezt az átszámolt értéket fogja tartalmazni.
 
\end_layout

\begin_layout Description
PhoneStateObserver interfész tartalmazza a telefon adatainak változásához
 tartozó értesítési, frissítési metódusok fejléceit.
 
\end_layout

\begin_layout Description
PhoneStateSubject interfész tartlamazza a PhoneStateObserver-hez kapcsolódó
 értesítési és regisztrálási függvények fejléceit.
\end_layout

\begin_layout Description
PrefsActivity egy egyszerű Activity, ami a beállítások megjelenítéséért
 felelős.
 Tartalmazza a menüket a többi Activity-hez hasonlóan, melyek segítségével
 elérhető a többi Activity is.
 A 
\shape italic
onSharedPreferenceChanged 
\shape default
metódus segítségével értesül az osztály a beállítások változásáról, így
 ellenőrizhető a megadott adatok helyessége.
 Az IP cím megadása esetén használom ezt a metódust, ha nem illeszekedik
 a megadott mintára a bevitt cím, akkor egy előre megadott, alapértelmezett
 IP címet álítok be, ami jól formázott és egy Toast üzenet segítségével
 értesítem a felhasználót a hibáról.
\end_layout

\begin_layout Description
TestActivity a felhasználó itt állíthatja be a tesztek paramétereit és elindítha
tja vagy leállíthatja teszt futtatását.
\end_layout

\begin_layout Description
TestObserver interfészen keresztül egy osztály a tesztek során érkező jelentések
ről értesülhet szöveges formában.
 
\end_layout

\begin_layout Description
TestSubject interfész a TestObserver-ek ki- és beregisztálásához szükséges
 metódusok fejlécét tartalmazza.
\end_layout

\begin_layout Subsection
Osztályok egymás közti kommunikációja teszt futtatás során
\end_layout

\begin_layout Standard
Az alábbi szekvencia diagrammon egy TCP teszt futása során használt üzenet
 és jelentés küldések láthatóak.
 Ez a teszt letöltési (Download) üzemmódban fut vagyis a szerver küldi az
 adatokat a TCPSender osztályon keresztül és a mobileszköz fogadja azokat
 a TCPReceiver segítségével.
\end_layout

\begin_layout Enumerate
Felhasnzáló megnyomja a 
\begin_inset Quotes sld
\end_inset

Start Test
\begin_inset Quotes srd
\end_inset

 gombot a TestActivity-ben és elindul a GSP helyszolgáltatás és a HttpService
 osztály példányosul és egy külön szálon, a háttérben futni kezd.
\end_layout

\begin_layout Enumerate
Előre megadott porton keresztül és a beállításoknál meghatározott IP címen
 elérhető HttpServer objektumhoz kapcsolódik egy Socket-en keresztül.
 
\end_layout

\begin_layout Enumerate
A kapcsolat létrejötte után a HttpServer példány létrehoz egy ServerThread
 példányt egy új szálon.
 Ez szolgálja majd ki a telefontól érkező teszt kéréseket.
\end_layout

\begin_layout Enumerate
A HttpService példány elküldi a ServerThread-nek a teszt beállításait és
 a receiveMessageFromServer metódusban aktívan vár a szerver válaszára.
  A sendResponse-ban küldött válaszban megkapja a szerver által használt
 teszt portját, ahova majd csatlakozni tud.
\end_layout

\begin_layout Enumerate
A ServerThread létrehozza a ReportSender osztályt, ami szükség esetén továbbítja
 a jelentéseket a mobilkészülék felé.
\end_layout

\begin_layout Enumerate
HttpServer létrehozza a ReportReceiver egy példányát és csatlakozik a ReportSend
erhez egy előre definiált porton.
\end_layout

\begin_layout Enumerate
A tesztnek megfelelő osztály létrejön a szerver oldalon, jelen esetben a
 TCPSender egy példánya, ami aszinkron módon egy párhuzamos szálon fog futni.
\end_layout

\begin_layout Enumerate
A TCPSender folyamatosan küldi a csomagokat a TCPReceiver felé, ami előre
 beállított intervallumonként a ReportReceiver-en keresztül jelentést küld
 egy Timer segítségével.
 Ez a jelentés az adatforgalomról tartalmaz adatokat, például az átviteli
 sebességet és az átvitt adat mennyiségét tartalmazza.
 A felhasználó a TestActivity Messages ablakában láthatja ezeket a jelentéseket,
 mindig a legfrissebb kerül a lista tetejére.
 
\end_layout

\begin_layout Enumerate
A ReportReceiver továbbítja a DriveTestApp application objektumnak az üzenetet
 egy Handler objektum segítségével.
 Itt a jelentések elmentődnek az adatbázisban és értesítésre kerülnek a
 TesztObserver interfészt megvalósítható osztályok példányainak az interfész
 update metódusával.
 A jelentések listája az application objektumban tárolódik.
\end_layout

\begin_layout Enumerate
A TestActivity Message ablakában megjelenik a frissített üzenetek listája,
 amit láthat a felhasználó.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption

\begin_layout Plain Layout
TCP teszt futása
\end_layout

\end_inset


\begin_inset Graphics
	filename tcptest.eps
	scale 80

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Tesztelés
\end_layout

\begin_layout Subsection
Statikus kódelemzés
\end_layout

\begin_layout Standard
A "Lint" program a Bell Laboratories terméke, az AndroidLint, része az Android
 SDK-nak.
 Ez az eszköz megvizsgálja a kódot, és javításokat ajánl.
 Lehetnek esetek amikor a program téved és az adott körülmények között az
 adott kód helyes, amire a Lint azt javasolja, hogy javítsd ki, így természetese
n nem helyettesíti a hozzáértő fejlesztőt.
\end_layout

\begin_layout Standard
Egyik nagyon gyakori hiba, hogy egy Toast létrehozásakor a 
\shape italic
makeText
\shape default
 metódust használják, és elfelejtik meghívni a 
\shape italic
show 
\shape default
metódust; a toast létrejön, de soha nem fog megjelenni! A hagyományos fordító
 nem tudja elkapni ezt a hibát, de az Android Lint képes erre, és ez csak
 egy a sok közül.
 Eclipse alól nagyon egyszerű és kényelmes a használata.
 Sok lehetséges hibaforrást megtalált és a fejlesztés során törekedtem rá
 hogy alacsonyan tartsam a Lint hibajelzések számát.
\end_layout

\begin_layout Subsection
Unit teszt
\end_layout

\begin_layout Standard
Az Android tesztek JUnit-on alapszanak.
 Hagyományos JUnit teszteket is használtam a HttpServer és HttpTestHandler
 projektek unit tesztjeinek írásakor, ezek nem használják az Android SDK-t.
 Az Android tesztesetekkel az Android komponensek megfelelő viselkedését
 tesztelem ezek a teszt osztályok az AndroidTestCase-ből öröklődnek, melyek
 a JUnit keretrendszeren túl Android specifikus setup, teardown, és egyéb
 segéd metódusokat tartalmaznak.
 A JUnit-beli Assert osztályt használva jeleníthetjük meg a teszt eredményeket
 és jelezhetjük a hibákat.
 Ezek a metódusok összehasonlítják kapott eredményeket a tesztben várt eredménye
kkel, ha nem egyeznek meg akkor kivételt generálnak, mely esetben a teszt
 hibát fog jelezni.
\end_layout

\begin_layout Subsubsection
DriveTesting applikáció
\end_layout

\begin_layout Standard
Külön tesztprojektet készítettem a DriveTesting applikáció teszteléséhez
 
\shape italic
DriveTestingTest 
\shape default
néven.
 
\end_layout

\begin_layout Description
DataStorageTest az adatbázis tábla létrehozását és az adatok beszúrását
 teszteli.
 Az insert (beillesztés) nem csak az adatbázis műveletet teszteli, hanem
 az adatbázis tábla attribútumainak helyes sorrendjét és típusát is.
 Ezenkívül a lekérdezéseket is teszteli, amik fontos szerepet játszanak
 a tesztelés folyamán, főként az exportálás és a térképes megjelenítés folyamata
iban.
\end_layout

\begin_layout Description
MainActivityUnitTest a két HashMap lista, vagyis a phoneDataList és a networkDat
aList alapértelmezett beállítását ellenőrzi.
 Továbba a PhoneStateObserver interfész által biztosított 
\shape italic
update
\shape default
 függvények implementációjának helyességét is teszteli.
\end_layout

\begin_layout Description
SeparatedListTest a SeparatedListAdapter osztály metódusait teszteli.
 Az Android BaseAdapter osztály metódusait felüldefiniálja és lehetőséget
 biztosít egy fejléces, kétszínű lista létrehozására.
 A teszt ezeket a funkciókat teszteli.
\end_layout

\begin_layout Subsubsection
HttpTestHandler
\end_layout

\begin_layout Description
HttpParserTest a HTTP*/1.0 típusú üzenetek feldolgozását végző osztályt teszteli,
 amit mind a szerver, mind a kliens oldal használ.
 A teszt során különböző bementi paraméterek, üzenetek esetén vizsgálom
 a feldolgozó (parser) osztály belső állapotát.
\end_layout

\begin_layout Description
LoggerTest a log fájl készítést és kezelést teszteli.
 A log fájl tartalmazza a program futása során bekövetkező, annak működésére
 vonatkozó üzeneteket.
 Ezek megkönnyíthetik az esetleges hibák felderítését és kijavítását is.
\end_layout

\begin_layout Description
ReportReceiverTest a HTTP*/1.0 üzenetek fogadását végző osztályt ellenőrzi.
 A küldött üzenetet feldolgozza és belső változóiban tárolja az utolsó üzenet
 értékeit, ezeket lekérdezem a teszt során és ellenőrzöm, hogy a megfelelő
 értékek szerepelnek-e az egyes változókban.
\end_layout

\begin_layout Description
ReportSenderTest a HTTP*/1.0 üzenetek küldésével foglalkozó osztály tesztelését
 végzi.
 A sendReportMessage működését vizsgálom, hogy a megadott üzenetet milyen
 formában küldi el.
\end_layout

\begin_layout Description
TCPReport a TCP jelentések feldolgozását végző osztály metódusainak tesztelésért
 felelős.
 Annak 
\shape italic
parseReport
\shape default
 metódusán keresztüli adatbevitel a szöveggé alakító 
\shape italic
toString
\shape default
 metódus segítségével ellenőrizhető.
 
\end_layout

\begin_layout Description
UDPReport a TCP verzióhoz hasonlóan hajtódik végre a tesztelés.
 A parseReportMetódusa van felüldefiniálva, hogy az UDP jelentés specifikus
 tagjait is feldolgozza, ez kerül tesztelésre.
\end_layout

\begin_layout Subsubsection
HttpServer
\end_layout

\begin_layout Description
HttpResponseTest a HttpResponse osztályt teszteli, ami egy HTTP*/1.0 típusú
 válaszüzenetet generál a szerver oldalon.
 Különféle bemeneti paraméterek esetén megvizsgálja a kimeneti szöveget
 és ezzel az elküldendő üzenetet hitelesíti.
\end_layout

\begin_layout Subsection
Komponens teszt
\end_layout

\begin_layout Standard
Android ActivityInstrumentationTestCase2 osztály segítségével létrehozhatóak
 olyan tesztek, melyek az egyes Android komponensek életciklusát befolyásolják.
 Kiválthatóak az egyes rendszerszintű események, így tesztelhetőek a komponensek
 egymásra hatása is.
 Például egy Activity objektum életciklusa kezdetekor meghívódik az objektum
 
\shape italic
onCreate
\shape default
 metódusa, amit az 
\shape italic
onResume 
\shape default
követ.
 Egy másik applikáció elindulása, vagy egy másik Activity-re váltás hatására,
 az 
\shape italic
onPause 
\shape default
metódus hívódik meg.
 Az Android keretrendszer nem biztosít lehetőséget ezen metódusok, események
 közvetlen meghívására, az Instrumentation-ok használatával ez mégis lehetővé
 válik.
 A tesztek futásuk során az Android emulátort használják.
\end_layout

\begin_layout Description
ExportActivityTest az ExportActivity osztályt teszteli.
 A menük közti navigálást és az Activity-k közti váltást és a felületen
 elhelyezett elemek működését teszteli.
\end_layout

\begin_layout Description
MainActivityInstrumentTest a MainActivityt teszteli és annak fontos adatainak
 alapértelmezett beállításait.
 Megvizsgálja a phoneDataList és networkDataList lista elemek értéket, ellenőrzi
 a menük közti navigálást és az Activity-k közti váltást és a felületen
 elhelyezett elemek működését teszteli.
\end_layout

\begin_layout Description
TestActivityTest a TestActivity osztályt tezteli az grafikus interfész helyes
 beállítását és megvizsgálja az alapértelmezett értékeket.
 A menük közti navigálást és az Activity-k közti váltást és a felületen
 elhelyezett elemek működését teszteli.
\end_layout

\begin_layout Subsection
Rendszer teszt
\end_layout

\begin_layout Standard
Teszt során a szerver és kliens programok együttes tesztelését végeztem
 Android emulátorral és mobilkészülékkel egyaránt - készülék típusa SonyEricsson
 Arc S, az Android verzió 4.0.4.
 Szerverként minden esetben az asztali számítógépem szolgált, mely segítségével
 tudtam adatforgalmat generálni a mobilkészülék és a számítógép között.
 A számítógépem egy router-en keresztül kapcoslódik az Internethez, melyen
 be kellett állítani a port továbbítást, hogy tudjon kommunikálni a mobilkészülé
kkel.
 A tesztek során számos hibát felderítettem a programban, melyeket alacsonyabb
 szintű tesztekkel nem volt lehetséges megtalálni, mert ezek csak a két
 komponens (szerver és kliens) együttes jelenléte és kommunikációja esetén
 lehetett felderíteni.
 Ilyen probléma volt a mobilkészülék NAT-olt hálózatban történő elérése.
 Biztonsági szempontok miatt nem lehet közvetlenül elérni a készülékeket
 publikus IP címen keresztül, így minden esetben a készüléknek kell kezdeményezn
i a kommunikációt, mely folyamat során nyit egy portot, amin keresztül a
 külső program tud válaszolni a mobilon futó programnak.
 Ez főleg UDP protokoll esetén volt probléma, ahol nincs állandó kapcsolat
 kiépítve, csak egy-egy üzenet elküldésének idejére.
 A tesztelések során valós környezteben is ki lett próbálva az applikáció,
 miközben aktívan kommunikált a szerverrel.
 A mérések grafikus megejelenítésekor a GPS jel pontatlansága gondot okozhat.
 Ennek minősége telefonkészüléktől és a terület műhold lefedettségétől is
 függ.
 Vannak területek, ahol centiméterre pontos értéket tud adni, máshol több
 méteres eltérés is jelentkezhet a valós pozícióhoz képest.
 Ezért használtam a térképes megejelenítésnél az OSMDroid útvonal generálási
 metódusát, ami útvonalra illeszti a GPS koordinátákat, így kis eltérés
 mellet is jó eredményeket tud mutatni a program.
 A tesztek során mind a kétféle protokollt és teszt módot kiprobáltam kombinálva
 egymással.
 Közben a mért adatokat, azok közül is a fel- és letöltési sebességet a
 Speedtest nevü programmal ellenőriztem, mely megméri, hogy az adott helyen
 milyen a sávszélességgel rendelkezik a hálózat.
 Az emulátoron különböző Android verziók melett eltérő felbontású, képarányú
 készülékkel is teszteltem a programot.
\end_layout

\begin_layout Subsection
Tesztelés során talált hibák
\end_layout

\begin_layout Standard
A rendszer tesztelés során kiderült, hogy a HttpService osztályban hibásan
 lett implementálva a szerverhez kapcsolódás, így minden teszt futtatáskor
 újra próbált csatlakozni a szerverhez.
 Ez azt eredményezte, hogy mindig az első teszt portot (5500) akarta használni,
 ami a többszöri kapcsolódást megakadályozta, mert a port még foglalt volt.
 Ebben az esetben a megoldás az volt, hogy a szerverhez csatlakozott Socket
 objektumot eltárolja a program és csak akkor hoz létre újat ha ez a Socket
 objektum még nem létezik, így a szerverrel való kapcsolat megmarad és új
 teszt indítása esetén a tesztportok egyesével léptetődnek.
\end_layout

\begin_layout Standard
A program tervezése során elkövetett hiba volt, hogy a TCP és UDP segédolsztályo
k maguk kezelték a Socket objektumokat és a csatlakozást.
 Ebben az esetben a tesztelés során kiderült, hogy nem lehet tudni, a kapcsolati
 hibák okát és a program egy hibás futás végén is úgy tért vissza mintha
 egy sikeres futásnak lett volna vége.
 Ebben az esetben a megoldás az volt, hogy a socket objektumokat egy szintel
 feljebb a HttpServer vagy a HttpService osztályok végzik és a létrejött
 Socket objektumokat a TCP és UDP osztályoknak továbbítják, és így a hibákról
 is értesül a felhasználó.
\end_layout

\begin_layout Standard
UDP protokollt használó tesztek esetén a hálózati kommunikáció során nem
 használhatóak a Socket objektumok, a kapcsolat nem építhető ki a szerver
 oldal felől.
 A mobil telefon IP címe nem publikus, általában NAT-olva van az operátorok
 hálózata, egyrészt biztonsági szempontok miatt, másrészt a kis címtartomány
 miatt.
 Ez azt eredményezte, hogy minden esetben a mobil készüléknek kell kezdeményezni
e a kommunikációt, ezzel lehetővé téve hogy a szerver üzenetetket tudjon
 küldeni a készülék felé.
 A tesztek során világossá vált, hogy a TCP esethez hasonló megoldást kell
 találnom, így keletkeztek a 
\shape italic
sendAddressToSenderThroughNAT
\shape default
 és 
\shape italic
getAddressThroughNAT
\shape default
 metódusok, amik kiküszöblik a NAT által keletkezett problémát.
\end_layout

\begin_layout Section
Továbbfejlesztési lehetőségek
\end_layout

\begin_layout Standard
A szerver jelenleg csak egy mobilkészüléket képes egyidőben kiszolgálni,
 ugyanis a ServerThread osztály mindig az előre megadott ServerPorton próbál
 Socket-et nyitni.
 Ha már foglalt a port akkor a következő Socket kreálása hibát fog jelezni
 és a kapcsolat nem tud kiépülni a második készülék és a szerver között.
\end_layout

\begin_layout Standard
A teszt jelenleg nem képes hanghívásokat kezelni, sem indítani, sem fogadni.
 Ezek használatához kernel szinten kéne módosításokat végezni, hogy a szökséges
 információk eljuthassanak az applikációhoz.
\end_layout

\begin_layout Standard
Továbbá a jelenlegi megoldással egyszerre csak egy teszt futtatható, megoldható
 lenne kis módosítással több teszt párhuzamos futtatása, de ha túl sok fut
 párhuzamosan, akkor befolyásolhatják egymás mért értékeit és így a teszt
 eredményét is.
 
\end_layout

\begin_layout Chapter
Összefoglalás
\end_layout

\begin_layout Standard
A szakdolgozatom elkészítésével sikerült betekintést nyerni az Android platformr
a való fejelsztés lépéseibe, valamint a mobilhálózatok bonyolúlt és szerteágazó
 világába.
 Első lépésben az Android platform került ismertetésre, mely a bemutatott
 alkalmazás implementálása mellett számos új lehetőségeket rejt.
 Mára már kiforrot mind a platform, mind a fejlesztői környezet, melyel
 nagyon könnyen fejleszthetünk alkalmazásokat.
 Bár sok lehetőséget nyújt a különféle applikációk fejlesztésében, a dolgozatom
 elkészítése során nem találtam módot arra, hogy a hivatalos Android SDK
 segítségével a hanghívásokat is tesztelhessem.
 Kutatómunkám során arra a következtetésre jutottam, hogy a szükséges információ
k alacsony szinten kerülnek letárolásra, illetve kezelésre, melyhez nem
 elég az Android SDK megváltoztatása sem.
\end_layout

\begin_layout Standard
Továbbá ismertettem a mobilhálózatokat és ezek generációit.
 Ezen leírásokból is kitűnik az egyre nagyobb mértékű és egyre inkább nagyobb
 hangsúlyt kapó mobiladatforgalom világában az enyém és az ehhez hasonló
 dignosztikai programoknak nagy szerepe van és lesz is.
 Olyan alkalmazást valósítottam meg, mellyel a telefonhálózatok operátorai
 költséghatékonyan megkönyíthetik a munkájukat.
 Természetesen még nagyon sok elemmel ki lehetne egészíteni a programot,
 ami még hatékonyabbá és többoldaluvá tehetné a programot, például a program
 tovább bővithető az Android nyújtotta új szolgáltatásokkal, illetve alacsony
 szintű fejlesztésekkel a telefonkészülékkel olyan hanghívások is tesztelhetőek,
 amit a dolgozatom nem támogat, így még gazdagabbá, hatékonyabbá lehet tenni
 tesztelést.
\end_layout

\begin_layout Chapter
Köszönetnyilvánítás
\end_layout

\begin_layout Standard
Szeretnék mindenkinek köszönetet modnani, aki közvetlen vagy közvetett módon
 segítette a dolgozat elkészülését.
\end_layout

\begin_layout Standard
Köszönettel tartozom témavezetőmnek Sike Sándornak, hogy lehetőséget biztosított
 munkám sikeres elvégzéséhez és dolgozatom megírásához.
 Köszönöm a segítőkész támogatását és dolgzatom alapos áttekintését.
 
\end_layout

\begin_layout Standard
Köszönöm Dósa István kollégámnak és Simonyi Tibor külső konzulensemnek a
 hasznos tanácsokat és támogatásukat a dolgozatom elkészítéséhez.
\end_layout

\begin_layout Standard
Végül szertném megköszönni családom türelmét és segíségét.
\end_layout

\begin_layout Chapter
Irodalomjegyzék
\end_layout

\begin_layout Itemize
Android, http://developer.android.com (2014.021.06)
\end_layout

\begin_layout Itemize
[ant] ant letöltése, http://ant.apache.org/manual/install.html (2014.021.06)
\end_layout

\begin_layout Itemize
[JDK] JDK letöltése, http://www.oracle.com/technetwork/java/javase/downloads/jdk7-
downloads-1880260.html (2014.021.06)
\end_layout

\begin_layout Itemize
Második generációs mobilhálózatok, http://en.wikipedia.org/wiki/2G (2014.021.06)
\end_layout

\begin_layout Itemize
Harmadik generációs mobilhálózatok, http://en.wikipedia.org/wiki/3G (2014.021.06)
\end_layout

\begin_layout Itemize
Negyedik generációs mobilhálózatok, http://en.wikipedia.org/wiki/4G (2014.021.06)
\end_layout

\begin_layout Itemize
HTTP 1.0 leírása, http://www.jmarshall.com/easy/http/ (2014.021.06)
\end_layout

\begin_layout Itemize
HTTP 1.0 szabvány, http://www.rfc-editor.org/rfc/rfc1945.txt (2014.021.06)
\end_layout

\begin_layout Itemize
Mobil jelerősségének számítása, http://en.wikipedia.org/wiki/Mobile_phone_signal
 (2014.021.06)
\end_layout

\begin_layout Itemize
[Wikipedia] mobil operáciosrendszerek, http://en.wikipedia.org/wiki/Mobile_operati
ng_system (2014.021.06)
\end_layout

\begin_layout Chapter
\start_of_appendix
Használt eszközök a fejlesztés során
\end_layout

\begin_layout Itemize

\series bold
Android SDK 
\series default
15.
 verzióját használom, a program ennél magasabb verziószámú Andorodi készülékeken
 is fut, de alacsonyabb verziójuak már nem támogatottak.
 Az SDK tartalmazza az Android specifikus könyvtárakat, amik használatával
 Android eszközön futtatható appplikációk készíthetőek.
 
\end_layout

\begin_layout Itemize

\series bold
Eclipse 
\series default
(Indigo) egy IDE, integrált fejelsztő környezet.
 Többnyire Java-ban íródott.
 Applikációk fejlesztésére használják, a plugin-ek használatával és fejlesztésév
el több féle programozási nyelven történő fejlesztést is támogathat.
 Ezen eszköz támogatja az Android platformra történő fejlesztést is, így
 ezt hasnzáltam a dolgozatom elkészítéséhez.
 Könnyen integrálható bele egy plug-in, aminek segítségével futtathatunk
 Android emulátrot, ami hibakeresés során nagyon hasznos eszköz.
\end_layout

\begin_layout Itemize

\series bold
Git 
\series default
egy nyílt forráskódú, elosztott verziókezelő szoftver, vagy másképpen egy
 szoftver forráskód kezelő rendszer, amely a sebességre helyezi a hangsúlyt.
 A Git-et eredetileg Linus Torvalds fejlesztette ki a Linux kernel fejlesztéséhe
z.
 Minden Git munkamásolat egy teljes értékű repository teljes verziótörténettel
 és teljes revíziókövetési lehetőséggel, amely nem függ a hálózat elérésétől
 vagy központi szervertől.
\end_layout

\begin_layout Itemize

\series bold
GitHub 
\series default
(www.github.com) egy Git-es fejlesztéseket támogató weboldal, mely ingyenes
 tárterületet biztosít a felhasználóknak.
 A dolgozatom készítése során itt is tároltam a adatokat és a forráskodókat
 is.
\end_layout

\begin_layout Itemize

\series bold
LyX 
\series default
egy nyílt forráskódú LaTeX dokumentum szerkesztő.
 Leegyszerűsíti és felgyorsítja a dokumentációt és sok közös LaTeX elem
 használatát, ugyanakkor engedi, hogy a felhasnzálók TeX kódot is használhassana
k, ahol szükséges.
 LyX weboldala: http://www.lyx.org.
\end_layout

\begin_layout Itemize

\series bold
Visual
\series default
 
\series bold
Studio 2010 Ultimate 
\series default
egy professzionális fejlesztő eszköz, mely nagyon sok programozási nyelven
 történő fejelsztést támogat.
 Ezen kívül széleskörűen támogatja a fejlesztés többi fázisát, aspektusát
 is így különféle UML diagrammok is készíthetőek a segítségével.
 ennek köszönhetően ezzel készítettem el a dolgozatban szereplő osztály
 és szekvencia diagrammokat.
\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"

\end_inset


\end_layout

\end_body
\end_document
