#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass book
\begin_preamble
% Using a custom title page, \title required
\title{}

% PDF Generation settings
\hypersetup{
    pdfstartview={FitH},
    linkcolor=black,
    citecolor=black,
    filecolor=blue,
    urlcolor=blue,
    linktoc=all
}

% Remove page numbering from the TOC
\addtocontents{toc}{
 \protect \thispagestyle{empty}
}

% Java code display
\usepackage{marvosym}
\newcommand{\hlstd}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\hlnum}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\hlesc}[1]{\textcolor[rgb]{0.64,0.08,0.08}{#1}}
\newcommand{\hlstr}[1]{\textcolor[rgb]{0.64,0.08,0.08}{#1}}
\newcommand{\hlpps}[1]{\textcolor[rgb]{0,0,1}{#1}}
\newcommand{\hlslc}[1]{\textcolor[rgb]{0,0.5,0}{#1}}
\newcommand{\hlcom}[1]{\textcolor[rgb]{0,0.5,0}{#1}}
\newcommand{\hlppc}[1]{\textcolor[rgb]{0,0,1}{#1}}
\newcommand{\hlopt}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\hllin}[1]{\textcolor[rgb]{0.17,0.57,0.69}{#1}}
\newcommand{\hlkwa}[1]{\textcolor[rgb]{0,0,1}{#1}}
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0,0,1}{#1}}
\newcommand{\hlkwc}[1]{\textcolor[rgb]{0.17,0.57,0.69}{#1}}
\newcommand{\hlkwd}[1]{\textcolor[rgb]{0,0,0}{#1}}
\definecolor{bgcolor}{rgb}{1,1,1}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language magyar
\language_package default
\inputencoding auto
\fontencoding global
\font_roman times
\font_sans helvet
\font_typewriter courier
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format pdf2
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing onehalf
\use_hyperref true
\pdf_title "Drive Testing szakdolgozat"
\pdf_author "Specker Zsolt"
\pdf_bookmarks false
\pdf_bookmarksnumbered true
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 4
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3.5cm
\topmargin 2.5cm
\rightmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation skip
\defskip smallskip
\quotes_language swedish
\papercolumns 1
\papersides 2
\paperpagestyle plain
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Kedves dokumentum felhasználó! Ezt a sablon dokumentumot az ELTE IKs szakdolgoza
t-dokumentációd megírásának megkönnyítéséért adom.
 Bárki felhasználhatja, átalakíthatja szabadon.
 A dokumentum elkészítéséhez használd a 
\begin_inset Quotes sld
\end_inset

szemecskés
\begin_inset Quotes srd
\end_inset

 ikont (Nézet, Ctrl+R).
 Ajánlott fordítási formátum: pdflatex.
\end_layout

\begin_layout Plain Layout
Az alábbiakban írok pár megjegyzést a munkád segítéséhez!
\end_layout

\begin_layout Itemize
Ajánlott átnézni a Dokumentum -> Beállítások...
 menüpontot a dokumentum szinte bármely tulajdonságának állításához, pl:
\end_layout

\begin_deeper
\begin_layout Itemize
Egy/kétoldalasság megváltoztatása: Dokumentum -> Beállítások...
 -> Oldal formátum -> Kétoldalas dokumentum
\end_layout

\end_deeper
\begin_layout Itemize
Hivatkozások hozzáadása:
\end_layout

\begin_deeper
\begin_layout Itemize
A hivatkozás céljánál Beszúrás -> Címke...
\end_layout

\begin_layout Itemize
A hivatkozás helyén Beszúrás -> Kereszthivatkozás...
 (formátumként kiválasztani a hivatkozás szövegstílusát is)
\end_layout

\end_deeper
\begin_layout Itemize
Ábrák ajánlott hozzáadása:
\end_layout

\begin_deeper
\begin_layout Itemize
Beszúrás -> Úsztatás -> Ábra
\end_layout

\begin_layout Itemize
A keret felső részére a kép beszúrása
\end_layout

\begin_layout Itemize
A keret-beli alsó keretbe az ábra nevének begépelése
\end_layout

\end_deeper
\begin_layout Itemize
Vektorgrafikus képek (pl UML modellek) optimális hozzáadása:
\end_layout

\begin_deeper
\begin_layout Itemize
Nyomtasd ki a programból a képet egy PDF nyomtatóval
\end_layout

\begin_layout Itemize
Konvertáld a képet PDF-ből EPS-re egy internetes szolgáltatás segítségével
 (ha lehet, ASCII és level 3-as, beágyazott betűtipusú formátumba)
\end_layout

\begin_layout Itemize
Beszúrás -> Képek
\end_layout

\begin_layout Itemize
Állíts be vágást a fehér részek eltüntetéséhez, 100% sorszélességet az oldalhoz
 állításhoz
\end_layout

\end_deeper
\begin_layout Itemize
Index kitöltése: Ha látsz egy szót amit az indexhez akarsz adni, Beszúrás
 -> Tárgyszó
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% Document front matter settings
\end_layout

\begin_layout Plain Layout


\backslash
frontmatter              % Starts front matterC/C+
\end_layout

\begin_layout Plain Layout


\backslash
pagestyle{empty}         % Removes page numbering (this needs to be reset
 in main matter)
\end_layout

\begin_layout Plain Layout


\backslash
begin{titlepage}         % Starts the custom title page
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle" tabularwidth="100col%">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<row interlinespace="2mm">
<cell multirow="3" alignment="center" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\begin_inset Graphics
	filename ELTE_logo.eps
	lyxscale 15
	width 3.5cm

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row interlinespace="2mm">
<cell multirow="4" alignment="center" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series bold
EÖTVÖS LORÁND TUDOMÁNYEGYETEM
\end_layout

\end_inset
</cell>
</row>
<row interlinespace="2mm">
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series bold
INFORMATIKAI KAR
\end_layout

\end_inset
</cell>
</row>
<row bottomspace="3mm" interlinespace="2mm">
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series bold
Programozáselmélet és Szoftvertechnológiai Tanszék
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.2mm"

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
\size largest
Drive testing Androiddal
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace 6em
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle" tabularwidth="100col%">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size large
Sike Sándor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size large
Specker Zsolt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size large
ELTE IK Programozáselmélet és
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size large
ELTE IK Programtervező
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size large
Szoftvertechnológiai Tanszék
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size large
Informatikus BSc
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size large
Dósa István
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size large
Ericsson Magyarország Kft.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\align center

\size large
Budapest, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
the
\backslash
year
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Ends the custom title page
\end_layout

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Document main matter start
\end_layout

\begin_layout Plain Layout


\backslash
mainmatter
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Resets the empty front matter page style to plain
\end_layout

\begin_layout Plain Layout

% Change this if an other style's prefered
\end_layout

\begin_layout Plain Layout


\backslash
pagestyle{plain}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Bevezetés
\end_layout

\begin_layout Section
Probléma leírása
\end_layout

\begin_layout Standard
A Drive testing egyfajta mérési módszere és értékelése a mobiltelefon hálózatok
 teljesítményének, kapacitásának, lefedettségének és minőségének.
 Ez a teszt fontos szerepet kap a telefonhálózatokat üzemeltető cégek -
 operátorok - hálózat tervezési, üzemeltetési stratégiáiban és nem utolsó
 sorban a hálózati hibák felderítésében.
 A drive test tipikusan az alábbi adatokat gyűjti össze a hálózatról:
\end_layout

\begin_layout Itemize
Jel intenzitás, erősség
\end_layout

\begin_layout Itemize
Adat fel- ls letöltési sebesség
\end_layout

\begin_layout Itemize
Elutasított és blokkolt hívások
\end_layout

\begin_layout Itemize
Handover információk (ez egyes tornyok, cellák közötti váltás)
\end_layout

\begin_layout Itemize
Szomszédos cella információk
\end_layout

\begin_layout Standard
\noindent
\begin_inset Wrap figure
lines 0
placement r
overhang 0in
width "40text%"
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Drive-Test-System.jpg
	scale 90

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption

\begin_layout Plain Layout

\size small
Egy Drive Test felszerelés
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
A manapság használt megoldások nagyon költségesek a drága eszközök és szakembere
k miatt.
 A mérés során a tesztelő - aki általában egy mérnök - egy speciálisan felszerel
t autóval kivonul a megadott területre, ahol a tesztet el kell végeznie.
 Majd bekonfigurálja az eszközöket a méréshez.
 Egy egyszerűbb felszerelés látható a jobb oldali képen.
 A mérés típusától függően lehet, hogy bonyolultabb és költségesebb eszközökre,
 felszerelésekre van szükség.
 Majd az autóval végigjárja a kijelölt útvonalat - akár többször is - miközben
 a mérési eredményeket rögzíti a számítógép egy speciálisan erre a célra
 fejlesztett szoftver segítségével.
 A mérés végeztével kiértékeli az eredményeket a program segítségével.
 Látható, hogy sok költséges, speciális eszközre van szükség a mérések elvégzésé
hez.
 
\end_layout

\begin_layout Section
Szakdolgozat célja
\end_layout

\begin_layout Standard
A szakdolgozatom célja egy 
\begin_inset Quotes sld
\end_inset

Drive testing" alkalmazás megvalósítása, egy kis költségvetésű Android operációs
rendszerű mobilkészülék segítségével.
 Nagy előnye ennek a megoldásnak a meglévő technológiával szemben, hogy
 a teszt elvégzéséhez elég egy mobiltelefon készülék és nem kell drága felszerel
ést és mérnököt alkalmazni.
 Az Android platform lehetőséget nyújt arra, hogy az alkalmazás információkat
 gyűjtsön a telefonról, valamint a mobilhálózatról.
 Ezen információk segítségével egy olyan program készíthető, amely képes
 részben vagy teljesen kiváltani a jelenleg használt technikát.
 Segítséget nyújt a telefonhálózat problémáinak felderítésében és a fejlesztendő
 területek feltérképezésében.
 
\end_layout

\begin_layout Standard
Az Android platformot választottam, mivel széles körben elérhető és a 
\begin_inset CommandInset href
LatexCommand href
name "Wikipedia"
target "http://en.wikipedia.org/wiki/Mobile_operating_system"

\end_inset

 adatai szerint ezt használják a legtöbben a világon.
 Így akár a felhasználók által gyűjtött teszt adatokat is felhasználhatják
 a telefon szolgáltatók, operátorok, mivel a program használata egyszerű,
 nem igényel szaktudást.
 Csak az adatok értelmezéséhez, feldolgozásához kell szakember.
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "60col%"
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename globalDataTraffic.jpg
	lyxscale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Mobil adatforgalom 2012-2017
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A szakdolgozatom leginkább a mobil adathívások tesztelésével és elemzésével
 foglalkozik, mivel a jövőben - 4G-s hálózatok esetén is - ez a terület
 különösen fontos szerepet fog játszani a mobilkommunikációban.
 Kimutatások szerint egyre növekszik a mobilhálózatok adatforgalma és 2017-re
 elérheti a havi 11,2 exabyte-nyi mennyiséget.
 A mobilkészülékek és hálózatok fejlődésével teret hódítanak a különféle
 szolgáltatások, mint a videó telefonálás, melyek növelik az adatforgalmat
 és szükségessé teszik a gyors és megbízható adatszolgáltatást.
 A felhasználók gyakrabban használják ezeket a szolgáltatásokat, mint a
 hagyományos hanghívást.
 Így a szolgáltatóknak is alkalmazkodniuk kell a megváltozott igényekhez,
 biztosítaniuk kell a nagyobb lefedettséget és megbízható, gyors adatátvitelt.
 
\end_layout

\begin_layout Chapter
Felhasználói dokumentáció
\end_layout

\begin_layout Section
Program bemutatása
\end_layout

\begin_layout Standard
A Drive Testing applikáció egy Android készüléken futtatható program, mely
 a telefon hálózatról tud különféle statisztikai adatokat gyűjteni.
 Ehhez tartozik egy szerver oldali program is, mellyel a mobil alakalmazás
 a mérések során aktívan kommunikál.
 Az alkalamazással futtatható tesztek adatokat gyűjtenek a telefonhálózatról
 és a készülékről a szerver programmal történő kommunikáció során, melyek
 fontos információkkal szolgálhatnak a telefonhálózatot üzemeltető operátoroknak.
 A tesztelő akár menetközben, autóban ülve tudja futtatni a teszteket futtani.
 A mérések során az adatok grafikus térképen is megtekinthetőek és a futtatás
 végeztével az eredmények ki is exportálhatóak az adatbázisból CSV formátumban
 egy tetszőleges fájlba.
\end_layout

\begin_layout Subsection
Program használatának feltételei
\end_layout

\begin_layout Standard

\series bold
Hardver feltételek
\end_layout

\begin_layout Standard
Az alkalmazás futtatásához szükséges legalább 4.0.4 verziójú Android operációsrend
szerű telefonkészülék.
 Korábbi verziójú rendszeren lehetséges, hogy egyes funkciók nem működnek
 megfelelően, illetve el se indul a program.
\end_layout

\begin_layout Standard
A mobilkészüléken be kell kapcsolni a mobilhálózaton keresztüli adatelérést
 (Beállítások -> Vezeték nélküli és mobilhálózatok ->Mobilhálózatok-> Adatok
 engedélyezve jelölőnégyzetet kell bepipálni), illetve a GPS pozíciók eléréséhez
 a Helyszolgáltatások menüpontban a GPS-műholdak jelölőnégyzet segítségével
 aktiválhatjuk.
\end_layout

\begin_layout Standard
Továbbá egy asztali számítógép, melyen található JVM (Java virtuális gép)
 a szerver oldali program futtatásához.
 Ennek internet hozáférést kell biztosítani.
 
\end_layout

\begin_layout Standard

\series bold
Szoftver feltételek:
\end_layout

\begin_layout Standard
A szerver oldali program fordításához és futtatásához szükséges a JDK (Java
 Developer Kit) legalább 1.6-os verziója, itt elérhető: 
\begin_inset CommandInset href
LatexCommand href
name "JDK letöltés"
target "http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html"

\end_inset

.
 
\end_layout

\begin_layout Standard
Valamint az Apache ant, amit innen tölthetünk le: 
\begin_inset CommandInset href
LatexCommand href
name "ant letöltés"
target "http://ant.apache.org/manual/install.html"

\end_inset

.
 
\end_layout

\begin_layout Standard
A feltelepített Drive Test programban be kell állítani a szerver oldali
 számítógép IP címét, ha router illetve egyéb más hálózati eszköz is érintett
 a kommunkációban, úgy biztosítani kell, hogy az applikációk kommunikálni
 tudjanak a 4500-as porton keresztűl.
 Továbbá a programok használhatják még a 5000, illetve a 5500 és 5600 közötti
 portokat a kommunkáció során.
\end_layout

\begin_layout Standard
Az alábbi lista tartalmazza a jogokat (permission), amit a mobilalkalmazás
 használ:
\end_layout

\begin_layout Description

\series bold
access coarse location:
\series medium
 az alaklamazásnak szüksége van erre ahhoz, hogy megjeleníthessük a készülék
 helyzetét a térképen és mérhessük a jelerősséget.
 Ezt a hálózati poziciót gyorsan el tudja nekünk kűldeni az adott hálózati
 eszköz, de elég durva becslést ad a telefon helyére, körülbelül 100 métres
 pontossággal.
 Ezt akkor használjuk, mikor a GPS szolgáltatás nem elérhető, például beltérben.
\end_layout

\begin_layout Description

\series bold
access fine location (GPS):
\series default
 a szabadban megfelelően erős a GPS műhold jele, ahhoz, hogy pontosan meghatároz
zuk a telefon helyzetét, ehhez a szolgáltatáshoz szükséges ez a jogosultság.
\end_layout

\begin_layout Description

\series bold
internet, access network state, read phone state
\series default
: a hálózat állapotának figyelésével kapunk értesítést a jel erősség változásról.
 Internet hozzáférés szükséges a szerverrel való kommunkikációhoz és a térkép
 frissítéséhez.
 A mérések során a telfon és a hálózat fontos paraméterei is rögzítésre
 kerülnek, kivéve a kritikus, azonosításra alakalmas paraméterek, mint például
 az IMEI/ESN szám, telefon szám, SIM széria szám vagy a MAC cím.
 Ezeket nem rögzíti az alkalmazás, csupán megjeleníti.
\end_layout

\begin_layout Description
read 
\series bold
and write external storage:
\series default
 külső tér írása és olvasása szökséges a jelentések, logok kiírásához.
 A felhesználó innen tudja lementeni a mérési eredményeket USB-n keresztül.
 
\end_layout

\begin_layout Section
Program használatának bemutatása
\end_layout

\begin_layout Subsection
Program telepítése
\end_layout

\begin_layout Subsubsection
Szerver oldali program futtatása
\end_layout

\begin_layout Standard
A program fordításához és futtatásához szükséges legalább a JDK 1.6 verziója.
 A 
\series bold
HttpServer
\series default
 mappába található ant 
\shape italic
build.xml 
\shape default
segítségével könnyedén fordíthatjuk és futtathatjuk az alkalmazást:
\end_layout

\begin_layout Description
- Egy tetszőleg terminálban menjünk a HttpServer könyvtárba.
\end_layout

\begin_layout Description
- Ezután az Apache ant program segítségével tudjuk fordítani az alaklamazást.
 Ezt a lépést csak egyszer kell végrehajtani, későbbiekben elég lesz csak
 a futtatásnál leírtakat elvégezni.
 A terminálban az 
\shape italic
ant
\shape default
 parancsot kell kiadni és a program fordítása elkezdődik.
\end_layout

\begin_layout Description
- Majd a sikeres fordítás végeztével az 
\shape italic
ant run 
\shape default
parancsal futtathatjuk a programot.
\end_layout

\begin_layout Description
- A program indulása után ezt az üzenetet fogja látni:
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
d:
\backslash
HttpServer>ant run
\end_layout

\begin_layout Plain Layout
Buildfile: d:
\backslash
HttpServer
\backslash
build.xml
\end_layout

\begin_layout Plain Layout
run:
\end_layout

\begin_layout Plain Layout
[java] Log file: d:
\backslash
HttpServer
\backslash
server.log
\end_layout

\begin_layout Plain Layout
[java] Log fileWriter created
\end_layout

\begin_layout Plain Layout
[java] HTTP_Server: Waiting for connection on port:4500
\end_layout

\begin_layout Plain Layout
[java]
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Telepítés a mobileszközre
\end_layout

\begin_layout Standard
A telepítéshez szükséges a DriveTesting.apk fájl és hogy a mobilkészülék
 csatlakoztatva legyen a számítógéphez és hozzáférésünk legyen a telefon
 SD kártyájához.
 A telepítés menete:
\end_layout

\begin_layout Standard
1.
 A külső program telepítéséhez kell egy fájlkezelő program, mint a Total
 Commander vagy az Apps Installer nevű program, amivel tudunk manuálisan
 telepíteni.
 
\end_layout

\begin_layout Standard
2.
 Engedélyezni kell a telefonon az ismeretlen forrásból való telepítést.
 Ehhez menjünk a 
\begin_inset Quotes sld
\end_inset

Beállítások
\begin_inset Quotes srd
\end_inset

 menüben, ott válasszuk az 
\begin_inset Quotes sld
\end_inset

Biztonság" részt.
 Majd pipáljuk be az “Ismeretlen források” opciót.
 Ezek után már képesek leszünk külső programokat is telepíteni.
 
\begin_inset Wrap figure
lines 0
placement o
overhang 0in
width "50col%"
status collapsed

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Graphics
	filename telepites1.png
	lyxscale 60
	scale 60

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Telepítés
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement o
overhang 0in
width "50col%"
status collapsed

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Graphics
	filename telepit2.png
	lyxscale 80
	scale 80

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Program ikonja
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
3.
 Kapcsoljuk össze a telefont és a számítógépet USB kábellel.
 A telefonon az értesítési területen válasszuk ki az USB részt, és csatlakoztass
uk a memóriakártyát.
 Ekkor a telefon leválasztja az SD kártyát, és lehetővé teszi hogy a számítógépü
nkkel elérjük azt.
\end_layout

\begin_layout Standard
4.
 Másoljuk fel a programot egy tetszőleges mappába, majd válasszuk le az
 SD kártyát a pc-ről, és csatlakoztassuk a telefonon.
 Indítsuk el a fájlkezelő programot, és keressük meg a megfelelő fájlt.
 Válasszuk ki az apk filet, ekkor feljön egy opció, hogy megnyitjuk a fájlt,
 vagy telepítjük.
 Mi most az utóbbit válasszuk, az ablak a bal oldali képen látható.
 A következő ablakban átnézhetjük a program legfontosabb tulajdonságait,
 majd az 
\begin_inset Quotes sld
\end_inset

Telepítés
\begin_inset Quotes srd
\end_inset

 gombra kattintva telepíthetjük.
\end_layout

\begin_layout Standard
5.
 A sikeres telepítést követően az alkalmazások között megjlenik a program
 ikonja, mellyel futtathatjuk azt.
 Az ikon a bal alsó képen látható.
 
\end_layout

\begin_layout Standard
6.
 Az indítást követően meg kell adni a programnak a szerver gép publikus
 IP címét.
\end_layout

\begin_layout Subsection
Menü áttekintése
\end_layout

\begin_layout Standard
A felhasználó a menüpontok segtségével navigálhat az egyes ablakok között.
 Összesen öt ablakot tartalmaz az alkalmazás.
 Az applikáció minden ablakban négy menüelem kap helyet.
 
\end_layout

\begin_layout Standard
Széles telefon kijelző esetén - mint amilyennel egy tablet rendelkezik -
 az összes menüpont megjelenik a képernyő tetején az aktuális ablak nevével
 együtt.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename widephone.jpg
	lyxscale 70
	scale 80

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption

\begin_layout Plain Layout
Menü tablet-en (4.7
\begin_inset Quotes srd
\end_inset

, 1280 * 720)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Kesekenyebb kijelző esetén a menüpontoknak csak az ikonja jelenik meg.
 
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename smallPhone.jpg

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Menü kis kijelzőn a készülék alján jelenik meg (4
\begin_inset Quotes srd
\end_inset

, 480*800 felbontás)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ikonok listája:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename mobil.png

\end_inset

- Main ablak 
\begin_inset Graphics
	filename test.png

\end_inset

- Test ablak 
\begin_inset Graphics
	filename m.png

\end_inset

- Térkép ablak
\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename export.png

\end_inset

- Export ablak 
\begin_inset Graphics
	filename setting.png

\end_inset

- Beálltások
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Ikonok
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Ablakok leirása
\end_layout

\begin_layout Subsubsection*
Main (fő) ablak
\end_layout

\begin_layout Standard
Az alakalmazás fő ablaka, ez jelenik meg az inditás után.
 A megjelenitett lista két fő részre bontható: az eslő tartalmazza a telefon
 adatatit (Phone Data), ezek nagyrésze nem változik, fontos paraméter a
 jel erősség érték (signal strength), ami a rádió hálózati torony által
 küldött jel erőssége.
 A második része a hálózati adatokat tartalmazza (Network Data).
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement o
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Graphics
	filename mainablak.png
	lyxscale 70
	scale 70

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Main ablak
\end_layout

\end_inset


\end_layout

\end_inset

Ezen adatok nagyrésze a telefon, illetve a hálózat aktuális állapotától
 függenek, mint például a hálózat tipusa (Network Type), ami lehet UMTS,
 EDGE, stb.
 Ez a telefon helyétől függ és persze az adott területen elérhető mobilhálózat
 szolgáltatásoktól.
 A mérések szempontjából fontos adatok a már emlitett szignál erősség, hálózat
 tipusa, ezeken kivűl az MCC, MNC, LAC és a CID, ezen értékek változása
 esetén a képernyő autómatikusan frissül a képernyőn is.
 Utóbbiak azonostják a telefonoperátort az adott országra vonatkozóan, és
 meghatározzák a mobilkészülék helyét, azaz, hogy az operátor melyik cellájában
 tartózkodik.
 MNC (Mobile Network Code) és az MCC (Mobile Country Code) együtt egyértelmúen
 meghatározza az operátort az adott országban, LAC (Location Area Code)
 a hálózat szólgáltatójához tartozó területi azonosító, CID (Cel ID) cella
 azonosító.
 A lista automatikusan frissűl, ha megváltozik egy érték.
 A felhasználó az ujja segtségével fel és le görgetheti a kijelzőn a táblázatot.
\end_layout

\begin_layout Subsubsection*
Test (teszt) ablak
\end_layout

\begin_layout Standard
Az alkalmazás fő része, ahonnan a felhasználó a teszteket tudja inditani.
 Egyszerre csak egy mérés futhat, és nem lehet menetközben megváltoztatni
 a beállitásokat.
 A beállitások a következőek lehetnek: feltöltés vagy letöltés teszt, azon
 belül UDP vagy TCP protokollok használatát lehet beállitani rádiógombok
 segitségével.
 A megadott értékek, beállítások elmentődnek és az ablakok közti váltáskor
 megörződik, illetve visszatöltődik, ha a felhasználó visszatér ehhez az
 ablakhoz.
 
\end_layout

\begin_layout Standard
A 
\begin_inset Quotes sld
\end_inset

Start test
\begin_inset Quotes sld
\end_inset

 feliratú gombra kattintva elkezdődik a teszt futtatás.
 Ez elöbb emlitett gomb beszürkül, ilyenkor nem fogadja a felhasználói események
et.
 A 
\begin_inset Quotes sld
\end_inset

Stop test
\begin_inset Quotes srd
\end_inset

 feliratú gomb kivilágosodik és fogadja a kattintás eseményet, ezzel lehet
 lálitani a futó tesztet.
 A teszt autmatikusan leáll ha nem siekrül elinditani a tesztelést valamilyen
 beállítási vagy hálózati oknál fogva.
\begin_inset Wrap figure
lines 0
placement o
overhang 0col%
width "50col%"
status collapsed

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Graphics
	filename testablak.png
	lyxscale 70
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Test ablak
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
A teszt futtatásához szükséges paraméterek a távoli szerver IP címe és a
 jelentés gyakoriságát módosíthatjuk a Settings (Beállitások) ablaknál.
\end_layout

\begin_layout Standard
A teszt futása során a felhaszáló egy előre megadott intervallumonként jelentést
 kap, ami tartalmazza a mérések aktuális eredményét: hálózat tipusát, a
 fel- és letöltési sebbesééget, UDP teszt esetén a jittert és a fogadott
 és az elveszett csomagok számát.
 Ez a riport a képernyő közepén találhtó lista tartalmazza.
 Ezt a listát törölheti a felhasználó, a 
\begin_inset Quotes sld
\end_inset

Clear logs
\begin_inset Quotes srd
\end_inset

 feliratú gombra kattintva.
 Az esetleges kapcsolati hibákról is ezen keresztűl értesül a felhasználó.
 Ezen hibák a 
\begin_inset Quotes sld
\end_inset

Hibaüzenetek
\begin_inset Quotes srd
\end_inset

 fejezetben lesznek bővebben kifejtve.
 
\end_layout

\begin_layout Standard
Az aktuális tartalma ennek a log listának elmentatő a 
\begin_inset Quotes sld
\end_inset

Save logs
\begin_inset Quotes srd
\end_inset

 gomb seitségével.
 Az elmentett fájl neve a az aktuális időbélyegből fog generálódni, például:
 201311031130.txt.
 A megadott beálitásoknak megfelelően és a tárolók elérhetőségétől föggően
 a külső vagy belső tárra fog elmentésre kerülni az applikáció könyvtárán
 belül.
\end_layout

\begin_layout Subsubsection*
Map (térkép) ablak
\end_layout

\begin_layout Standard
A térkép megejeleitéséhez szükséges mobil internet kapcsolat és GPS adat
 használat engedélyezés a pontos pozició meghatározására.
 A felhasználó kiválaszthatja, hogy melyik teszt eredményeit szeretné látnia
 térképen megjelenítve.
 Erre szolgál a két oldalsó gomb: a "Set Test ID
\begin_inset Quotes srd
\end_inset

 és a 
\begin_inset Quotes sld
\end_inset

Set Test Name
\begin_inset Quotes srd
\end_inset

 gombok.
 A 
\begin_inset Quotes sld
\end_inset

Set Test ID
\begin_inset Quotes srd
\end_inset

 feliratú gombbal a felhasználó egy listából kiválaszthatja, hogy melyik
 teszt futást szeretné látni, annak azonosítója alapján.
 A 
\begin_inset Quotes sld
\end_inset

Set Test Name
\begin_inset Quotes srd
\end_inset

 gomb segítségével a teszt elnevezése alapján adhatja meg a látni kívánt
 tesztet.
 
\end_layout

\begin_layout Standard
Ha a felhasználó az 
\begin_inset Quotes sld
\end_inset

ALL
\begin_inset Quotes srd
\end_inset

 -t választja - akár test id-ként, akár test névként - a térképen az összes
 pont megjelenik és össze lesznek kötve úttal, akkor is ha valójában nem
 egy méréshez tartoztak.
 Ez megkönnyíti a pontok megkeresését a térképen.
 
\begin_inset Wrap figure
lines 0
placement o
overhang 0col%
width "50col%"
status collapsed

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Graphics
	filename map.png
	lyxscale 70
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Térkép ablak
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ha éppen fut egy teszt, amikor ez az aktív képernyő, akkor a futó tesztre
 vonatkozó adatokat láthatja a felhasználó és újabb jelentések érkezésekor
 a térkép frissül és az új mérések is láthatóak lesznek.
 
\end_layout

\begin_layout Standard
A térképen a színes pontok mérési pontokat jelölnek, a jelentés rögzítésének
 idejében az adott helyen volt a mobil készülék.
 Az egyes pontokra kattintva részletes információt kap a felhasználó egy
 felugró ablak segítségével.
 Ez tartalmazza többek között a jelerősséget, le és feltöltési sebességet
 és cella információkat.
 
\end_layout

\begin_layout Subsubsection*
Export ablak
\end_layout

\begin_layout Standard
Az ablak tetején található mezőbe írható be a kimeneti fájl neve.
 Ezt mindenképpen ki kell tölteni.
\end_layout

\begin_layout Standard
A program által generált teszt eredények fájlba menthetőek CSV formátumban.
 A CSV fájl első sora a fejléc: id, test_id, test_name, time, lat, lon,
 signal_strength, up_speed, down_speed, jitter, lost_packet, sum_packet,
 mcc, mnc, lac, cid, rate, network_type mezőkkel, ahol az id az adatbázis
 rekord azonosítója, a test_id a teszt futtatáskor generált teszt azonosító,
 test_name a teszt neve, amit a felhasználó a beállítások között adott meg,
 time a bejegyzés ideje, lat avagy latitude szélességi koordináta, a lon
 azaz longitude a hosszúsági koordinátája a mérés helyének, up_speed és
 a down_speed a fel- és letöltési sebesség, jitter-nek az UDP protokolt
 használó tesztek esetén van jelentősége és a csomagok közti késést mutatja,
 a lost_packet és sum_packet szintén UDP teszt esetén jelentős, az elveszett
 és az eddigi összes csomag számát jelentik, és a network type pedig a hálózat
 típusa (UMTS, EDGE, stb.), végül a rate a fel ésletöltési sebeség mértékegységét
 jelölik (Mbits, Kbits, stb.).
 Ez után lévő bejegyzések az adatbázis sorainak megfelelő adatok.
\end_layout

\begin_layout Standard
Lehetséges kiválasztani egy teszt ID-t, vagy teszt nevet, melyet ki akarunk
 exportálni, de akár az összes elemet is kiexportálhatjuk (ALL).
 Ezt a 
\begin_inset Quotes sld
\end_inset

Set Test ID
\begin_inset Quotes srd
\end_inset

 vagy a 
\begin_inset Quotes sld
\end_inset

Set Test Name
\begin_inset Quotes srd
\end_inset

 nevű gombra kattintva tehetjük meg.
 Rákattintva a felugró abalkból választhatjuk ki a megfelelő teszt azonosítót.
\begin_inset Wrap figure
lines 0
placement o
overhang 0col%
width "50col%"
status collapsed

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Graphics
	filename exporting.png
	lyxscale 70
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Export ablak
\end_layout

\end_inset


\end_layout

\end_inset

Fontos megjegyezni, hogy csak a program adatbázisában található teszt azonosítók
 közül választhat a felhasználó.
 Ha még nem futtatott tesztet, akkor nem lesz bejegyzés és így exportálható
 adat sem.
 Továbbiakban meg kell adnunk a fájl nevét az 
\begin_inset Quotes sld
\end_inset

Output file name
\begin_inset Quotes srd
\end_inset

 szövegmezőben, mely a külső memória egységen lesz letárolva 
\begin_inset Quotes sld
\end_inset

sdcard/Android/com.drivetesting/files/export
\begin_inset Quotes srd
\end_inset

 illetve, ha ez nem lehetséges akkor az applikáció könyvtárában 
\begin_inset Quotes sld
\end_inset

data/data/com.drivetesting/export
\begin_inset Quotes srd
\end_inset

.
 Az 
\begin_inset Quotes sld
\end_inset

Export To CVS
\begin_inset Quotes srd
\end_inset

 feliratú gombra kattintva elkezdődik az adatok kimentése a megadott fájlba
 és megjelenik egy ablak 
\begin_inset Quotes sld
\end_inset

Exporting database...
\begin_inset Quotes srd
\end_inset

 felirattal.
 A dialógus ablakban forgó icon jelzi, hogy még tart az exportálási folyamat.
\end_layout

\begin_layout Standard
A művelet befejeztével az ablak automatikusan bezáródik és egy felugró üzenetabl
akban megjelnik, hogy sikeres volt-e a művelet vagy sem.
 Sikeres exportálás esetén a fájl elérésiútja us megjelenik.
\end_layout

\begin_layout Subsubsection*
Setting (beállitások) ablak
\end_layout

\begin_layout Standard
Az itt megejelnő paraméterek segitségével konfigurálható a teszt futtatás,
 ileltve a program működése.
 Ezek a paraméterek a program bezerása után is megmaradnak, nem kell a felhaszná
lónak újra beállitania ezeket.
 
\end_layout

\begin_layout Standard
Teszt futtatásra vonatkozó paraméterek:
\end_layout

\begin_layout Itemize
Server IP address - szerver publikus IP címe
\end_layout

\begin_layout Itemize
Buffer size - egy-egy átküldött adatmennyiség mérete
\end_layout

\begin_layout Itemize
Report period - jelentés gyakoriságának ideje
\end_layout

\begin_layout Itemize
Test Name - teszt neve
\end_layout

\begin_layout Itemize
Units - sebesség és a fogadott adatok mennyiségének mértékegységét álíthatóak
 be
\end_layout

\begin_layout Standard
Fájl kezelésre vonatkozó beállitások:
\end_layout

\begin_layout Standard
?
\end_layout

\begin_layout Subsection
Program használata és teszt futtatás
\end_layout

\begin_layout Standard
A fő ablakban is nyomon lehet követni a jel erősség, hálózat típúsának és
 a cella információk változását, de ilyenkor sajnos nem kerül eltárolásra
 a változás, így nem lehet viszakövetni sem.
 A teszt ablakban van lehetőség tesztek futtatására.
 Választhatunk UDP vagy TCP protokollok és fel- vagy letöltés között a rádiógomb
ok segítségével.
 A teszt futtatása előtt győzödjön meg róla, hogy a szerver oldali program
 a HttpServer fut és elérhető a szerver és a fentebb említett portok szabadok.
 A szerver publikus IP címét be kell álítani a Beállítások menüponban.
 A teszt futtatásához a 
\begin_inset Quotes sld
\end_inset

Start test
\begin_inset Quotes srd
\end_inset

 gombra kell kattintani.
 Ezután elindul az adatok fel vagy letöltése a beállításoknak megfelelően.
 A teszt addig fut amíg le nem állítják a 
\begin_inset Quotes sld
\end_inset

Stop test
\begin_inset Quotes srd
\end_inset

 feliratú gombbal.
 Az előre megadott időközönként (report intervallum) a program megvizsgálja
 és kiírja az aktuális értékeket az adatbázisba és mejelennek a 
\begin_inset Quotes sld
\end_inset

Messages
\begin_inset Quotes srd
\end_inset

 fejlécű listában a teszt ablakban.
 Ezek a bejegyzések tartalmazzák a különböző mérési eredményeket.
 A térképen látható az épp futó teszt és méréseknek megfelelően frissülnek
 az adatok rajta.
 Lehetőség van korábbi tesztek eredményeit is megjeleníteni a térképen teszt
 azonosító vagy teszt név alapján.
 Bármely tesztet ki lehet exportálni CSV formátumba az adatbázisból név
 vagy azonosító alapján.
 
\end_layout

\begin_layout Subsection
Hibaüzenetek
\end_layout

\begin_layout Standard
mikor jelez a program hibát és mit tegyen a felhasználó ha ilyennel találkozik
 (pl.
 nem elérhető a GPS szolgáltatás, stb.)
\end_layout

\begin_layout Chapter
Fejlesztői dokumentáció
\end_layout

\begin_layout Section
Mobilhálózatok bemutatása
\end_layout

\begin_layout Subsubsection*

\series bold
Mobilhálózatok kialakulása
\end_layout

\begin_layout Standard
Már a második világháborúban képesek voltak rádiótelefonos kapcsolatot kiépíteni
 katonai használatra.
 Kézi rádió adó-vevők már az 1940-es évektől elérhetőek voltak, pár telefon
 társaságnak volt gépkocsiban is használható mobil telefon készüléke.
 A korai készülékek testesek voltak és sok áramot fogyasztottak, a hálózat
 pedig csak néhány szimultán beszélgetést tudott csak kiszolgálni.
 
\begin_inset Wrap figure
lines 0
placement o
overhang 0col%
width "50col%"
status open

\begin_layout Plain Layout
\noindent
\align right
\begin_inset Graphics
	filename 621px-Mobile_radio_telephone.jpg
	scale 50

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Első mobil telefonok egyike
\end_layout

\end_inset


\end_layout

\end_inset

Az egyesült államokbeli Bell laboratórium mérnökei olyan rendszeren dolgoztak,
 ami képessé teszi a mobil felhasználókat hívások kezdeményezésére és fogadására
 akár az autójukból.
 Az AT&T vállalat 1947-ben megalkotta az első mobiltelefon hálózatot a Mobile
 Telephon Service-t (MTS).
 5,000 ügyféle volt és körülbelül heti 30 000 hívást bonyolítottak rajta.
 A cella technológia bevezetése lehetővé tette a frekvenciák sokszori újrahaszno
sítását kis szomszédos területeken, melyeket alacsony teljesítményű adók
 segítségével fedtek le.
 Ez lehetővé tette gazdaságilag megvalósítható módon a mobiltelefonok széles
 körben való elterjedését.
\end_layout

\begin_layout Standard
A mobil telefonok fejlődése jól nyomon követhető az egymást követő generációkon,
 a korai "0G" szolgáltatásokon keresztül az első generációs (1G) analóg
 cellás hálózatok és második generációs (2G) digitális mobil hálózatokon
 át a harmadik generációs (3G) szélessávú adat szolgáltatásokig.
 Napjainkban fejlődnek és egyre inkább elterjednek a negyedik generációs
 (4G) native-IP hálózatok.
\end_layout

\begin_layout Subsubsection*

\series bold
Cellák koncepciója
\end_layout

\begin_layout Standard
1947-ben Douglas H.
 Ring és W.
 Rae Young a Bell laboratórium mérnökei javasolták a hatszögletű cellák
 használatát a mobil hálózatokban.
 Akkoriban ez még nem volt megvalósítható csupán két évtizeddel később,
 mikor Richard H.
 Frenkiel, Joel S.
 Engel és Philip T.
 Porter mérnökök kiterjesztették a korábbi javaslatot és egy sokkal részletesebb
 tervet dolgoztak ki.
 Porter volt, aki először javasolta, hogy az adótornyok használják a már
 jól ismert irányított antennákat, annak érdekében, hogy redukálják az interfere
nciát és növeljék a csatornák újrahasznosíthatóságát.
\begin_inset Wrap figure
lines 0
placement o
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Transmitting_tower_top_us.jpg
	scale 50

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Többirányú mobilhálózati antenna
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ezekben a korai időkben a mobilkészüléknek az adótorony által lefedett körzetben
 kellett maradnia, ahhoz hogy szolgáltatás folyamatos maradjon, vagyis a
 szolgáltatás nem volt folytonos, átjárható az egyes cellák között.
 A koncepciók, mint a frekvencia újrahasználás és az átadás (handoff vagy
 handover) számos új mobiltelefon hálózati koncepciók alapját képezték.
 1970-ben Amos E.
 Joel Bell Laboratórium mérnöke feltalálta a három oldalú antennát, hogy
 segítse a hívások átadásának folyamatát egyik cellából a másikba.
\end_layout

\begin_layout Subsection
Mobilhálózatokban gyakran használt kifejezések leírása
\end_layout

\begin_layout Subsubsection*

\series bold
Hozzáférési Technológiák
\end_layout

\begin_layout Description

\series bold
FDMA
\series default
 (Frequency Division Multiple Access) a leggyakoribb analóg rendszer.
 Ez a technika a spektrum frekvenciatartományokra való feldarabolásán alapszik
 és egy frekvenciasávot t'rs
\backslash
t egy felhasználóhoz.
 Egy csatornát egy időben csak egy előfizető használhat, így egy csatorna
 lezárul a beszélgetés idejére más felhasználók elől, amíg le nem teszik,
 vagy át nem adódik a beszélgetés egy másik csatornának.
 A "full-duplex" FDMA átvitelnek két csatornára van szüksége, egy az adatok
 küldésére és egy másik a fogadására.
 FDMA technikát az első generációs analóg rendszerekben használták.
\end_layout

\begin_layout Description

\series bold
TDMA
\series default
 (Time Division Multiple Access) nagyobb kapacitásra volt képes, mert az
 egyes frekvenciákat időszeletekre (time slot) osztotta.
 TDMA rendszerben a felhasználók az egész frekvenciatartományt használhatták,
 több felhasználó osztozott ugyanazon a frekvencia csatornán amiből egy-egy
 időszeletet kaptak.
 TDMA a második generációs mobil hálózatok domináns technológiája.
\end_layout

\begin_layout Description

\series bold
CDMA
\series default
 (Code Division Multiple Access) szórt spektrumú technológián alapul.
 Titkosított adat átvitelt is lehetővé tette, ezért régóta használják katonai
 célokra.
 CDMA megnövelte a spektrum teljesítő képességét azzal, hogy a felhasználók
 az összes csatornát használhatják egy időben.
 Az adások az egész hullámsávot kihasználják, és minden hang vagy adat híváshoz
 egy egyedi kód tartozik, ami megkülönböztethetővé teszi egymástól a hívásokat.
 
\end_layout

\begin_layout Subsubsection*

\series bold
Mobil hálózati szabványok
\end_layout

\begin_layout Description

\series bold
PSTN
\series default
 (Public Switched Telephone Network) nyilvános vonalkapcsolt telefonhálózat.
 Telefon vezetékek, optikai kábelek, mikrohullámú átviteli állomások, kommunikác
iós műholdak és tengeralatti telefon kábelek kötik össze a kapcsolási központoka
t, hogy bármely telefon készülékkel felvehessük a kapcsolatot a világon.
 Eredetileg a hálózat analóg, vezetékes telefon rendszer volt, PSTN majdnem
 teljesen digitális, mobil és vezetékes telefonokat is tartalmaz.
 Egyetlen globális címtartománya van a telefonszámoknak, melyet a E.163 és
 E.164 szabványok írnak le.
 Az összekapcsolt hálózatok és az egységes számozásnak köszönhetően bármely
 telefonról hívható bármely másik készülék.
\end_layout

\begin_layout Description

\series bold
GSM 
\series default
(Global System for Mobile communication) ezt a szabványt az ETSI (European
 Telecommunications Standards Institute) a második generációs (2G) mobilhálózati
 protokollok leírására.
 A GSM sztenderd váltotta le az első generációs (1G) analóg hálózatot egy
 új, digitális, teljes kétirányú kommunikációt lehetővé tevő, vonalkapcsolt
 hálózat bevezetésével.
 Ezt később kiegészítették azzal, hogy belevették az adatkommunikációt is
 a szabványba, először vonalkapcsolt átvitellel, majd csomagkapcsolt átvitellel:
 GPRS (General Packet Radio Services) és EDGE (Enhanced Data rates for GSM
 Evolution vagy EGPRS).
\end_layout

\begin_layout Description

\series bold
GPRS 
\series default
(General Packet Radio Service) egy csomagkapcsolt szolgáltatás 2G és 3G
 kommunikációs rendszerekben.
 A GPRS-t az ETSI szabványosította, napjainkban a 3GPP (3rd Generation Partnersh
ip Project) tartja karban a szabványt.
 A GPRS szolgáltatás jellemzője a változó teljesítmény és késés, melyek
 mértéke a rendszert egyidejűleg használók számától függ.
 A vonal kapcsolt rendszerrel ellentétben, ahol szolgáltatás minősége (Quality
 of Service) biztositott a kapcsolat ideje alatt.
 2G-s rendszerben a GPRS által biztosított adatráta 56–114 kbit/s.
 A 2G és GPRS technológiák kombinációját néha 2.5G-nek szokták hívni, ami
 a 2G és a 3G mobil technológiák között helyezkedik el.
 Mérsékelt sebességű adatátvitelt biztosít a GSM rendszerben, az addig kihasznál
atlan több csatornás idő osztásos (TDMA: Time division multiple acces) technológ
ia segítségével.
\end_layout

\begin_layout Description

\series bold
EDGE
\series default
 (Enhanced Data rates for GSM Evolution), más néven EGPRS (Enhanced GPRS)
 mobiltelefon technológia, ami nagyobb adatátviteli sebességet tesz lehetővé.
 EDGE a 2003 év elején került bevezetésre a GSM hálózatokban.
 A 3GPP szabványosította és GSM család részévé vált.
 Kifinomult kódolási eljárások bevezetésének köszönhetően megnőtt a csatornánkén
t elérhető bitráta, háromszoros kapacitás és teljesítmény beli növekedést
 eredményezett a hagyományos GSM/GPRS kapcsolathoz képest.
 A továbbfejlesztett EDGE kisebb késést és több mint kétszeres teljesítmény
 növekedést biztosít.
 A legnagyobb bitráta elérheti a 1Mbit/s-ot, átlagosan pedig a 400kbit/s-ot.
\end_layout

\begin_layout Description

\series bold
W-CDMA
\series default
 (Wideband Code Division Multiple Access) egy 3G mobilhálózati rádiós interfész
 sztenderd.
 A leggyakrabban használt tagja az Universal Mobile Telecommunications System
 (UMTS) családnak és néha az UMTS szinonimájaként használják.
 A DS-CDMA csatorna hozzáférési és FDD duplex módszereket alkalmazza, hogy
 nagyobb sebességre legyen képes és több felhasználót tudjon kiszolgálni
 a TDMA és TDD (time division duplex) rendszerekhez képest.
 Ugyanazt a központi hálózatot használja, mint a 2G GSM hálózat.
 Code Division Multiple Access kommunikációs hálózat sok cég közreműködésével
 jött létre, de a CDMA (inkább W-CDMA) cellás telefon hálózat fejlesztésében
 a Qualcomm dominált.
 Qualcomm volt az első cég, akinek sikerült alkalmazható és költséghatékony
 megoldást találnia: ez volt a korai IS-95 rádióinterface sztenderd, melyből
 a CDMA2000 (IS-856/IS-2000) fejlődött ki.
 CDMA2000 hálózatok széles körben elterjedtek különösen Amerikában.
 Azonban az eltérő követelmények és felépítés megakadályozta a globális
 elterjedését.
 A a meglévő rádiós interfészekkel való inkompatibilitás és a nagy költséggel
 járó fejleszthetőség ellenére a W-CDMA egy meghatározó szabvánnyá vált.
 A W-CDMA egy pár 5 MHz széles rádió csatornát használ, míg a CDMA2000 egy
 vagy több pár 1.25 MHz rádió csatornát.
 Habár a W-CDMA szintén CDMA átviteli technikát alkalmaz, akár a CDMA2000,
 a W-CDMA nem egyszerűen egy széles sávú verziója a CDMA2000-nak.
 Mérnöki szempontból a W-CDMA különböző optimalizálási lehetőséget nyújt
 költség, kapacitás és teljesítmény között.
 Specifikációk egész halmazát tartalmazza, melyek részletesen definiálják
 a protokollokat, a kommunikációt a készülékek és a tornyok között, hogyan
 kell modulálni a szignálokat és azt is hogyan kell az adatokat strukturálni.
\end_layout

\begin_layout Description

\series bold
UMTS
\series default
 (The Universal Mobile Telecommunications System) harmadik generációs mobil
 hálózati rendszer.
 A 3GPP (3rd Generation Partnership Project) fejlesztette ki és tartja karban.
 W-CDMA hozzáférési technológiát használ a jobb hálózati kihasználtság és
 sávszélesség miatt.
 UMTS specifikál egy teljes hálózati rendszert, melybe beletartozik a hozzáférés
i hálózat (UMTS Terrestrial Radio Access Network, UTRAN), a központi hálózat
 (core network) és a felhasználók SIM általi azonosítása.
 Az EDGE és a CDMA2000 ellentétben az UMTS új bázis állomást és frekvencia
 allokációs módszert igényel.
 Az UMTS által támogatott maximális adat átviteli ráta 42 Mbit/s, ha HSPA+
 alkalmaznak a hálózatban és 7.2 Mbit/s HSDPA használat esetén.
 Ezek a sebességek szignifikánsan gyorsabbak , mint a GSM 9.6 kbit/s-os hibajavít
ásos vonalkapcsolt adatátvitele, vagy a CDMAOne csatornák 14.4 kbit/s rátája.
 2006 óta UMTS hálózatokat számos országban feljavították a High Speed Downlink
 Packet Access (
\series bold
HSDPA
\series default
) technikával, melyet néha 3.5G néven emlegetnek.
 HSDPA segítségével a letöltési sebesség elérheti a 21 Mbit/s-ot.
 A feltöltési sebesség javítását támogató technológia a High-Speed Uplink
 Packet Access (
\series bold
HSUPA
\series default
).
 Az első UMTS hálózatot 2002-ben indították be, nagy hangsúlyt fektetve
 az olyan mobil alkalmazásokra, mint a mobil TV és videóhívás.
 A nagy adatátviteli sebességet gyakran Internet elérésre használják.
 
\end_layout

\begin_layout Description

\series bold
LTE
\series default
 (Long-Term Evolution) 4G LTE, a legújabb sztenderd a mobiltelefonok és
 adat terminálok közötti nagy sebességű vezeték nélküli adatkommunikációra.
 GSM/EDGE és UMTS/HSPA hálózati technológiákon alapszik, de nagyobb kapacitást
 és sebességet nyújt különböző rádiós interfészek együttes alkalmazásával.
 A világ első publikus LTE szolgáltatója a TeliaSonera Osloban és Stockholmban.
 Várhatóan az LTE lesz az első igazán globális mobiltelefon sztenderd, habár
 a országonként különböző frekvenciasávok használata miatt csak a többsávos
 telefonok lesznek képesek kihasználni minden országban az LTE szolgáltatást.
 Míg a korábbi technológiák 28 Mbit/s elméleti maximumot támogatták, az
 LTE 326 Mbit átvételére lesz képes másodpercenként, 20 MHz széles frekvenciatar
tományon.
 Az LTE sztenderd csak IP hálózatokat támogatja.
 A GSM, UMTS és CDMA2000 hagyományos vonalkapcsolt hálózatok, így az LTE-vel
 való együtt működés miatt át kell tervezni a hálózatokat.
 Erre több fél megoldást dolgoztak ki:
\end_layout

\begin_layout Description

\series bold
VoLTE 
\series default
(Voice Over LTE) megközelítés IP Multimedia Subsystem (IMS) hálózaton alapszik.
 Ezzel a megoldással a hangszolgáltatás adatfolyamként továbbítódik az LTE
 állomáson keresztül.
 Ez azt jelenti, hogy nem kell módosítani a hagyományos vonalkapcsolt hálózatot,
 képes lesz a 4G-s hívást adatcsomagként továbbítani.
 Másik megközelítés a 
\series bold
CSFB 
\series default
(Circuit Switched Fallback).
 Eben az esetben az LTE csak adatcsomag szolgáltatást nyújt, és a hanghívások
 vonalkapcsolt hálózatban dolgozódnak fel.
 Ezt a megoldást használva az operátoroknak csak az MSC-t kell frissíteniük
 IMS telepítés helyett.
 Hátránya a hosszabb hívás kiépítési idő.
 A jobb minőségű hang biztosításához a 3GPP megköveteli legalább az AMR-NB
 kodek (narrow band) használatát, de a javasolt beszéd kodek VoLTE-hoz az
 Adaptive Multi-Rate Wideband, avagy a HD Voice.
\end_layout

\begin_layout Subsubsection*

\series bold
Mobil hálózat elemei
\end_layout

\begin_layout Description
BSC (Base Station Controller) több tíz esetleg több száz BTS-t irányít.
 A BSC rádió csatornák kiosztásáért felelős, mérési eredményeket fogad a
 mobil készülékektől és a BTS-ek közötti handover-eket kezeli.
 BSC fő funkciója összekötőként viselkedik a BTS-ek és a Mobile Switching
 Center (MSC) között.
 Általában a hálózatokban gyakorta úgy strukturálják, hogy számos BSC-t
 elosztanak a régiókban közel a BTS-ekhez, melyek egy nagy központosított
 MSC site-al állnak kapcsolatban.
 MSC-ket és Service GPRS Support Node-okat (SGSN) is kiszolgál (abban az
 esetben ha GPRS-t használ).
 
\end_layout

\begin_layout Description
BSS (Base Station Subsystem) része a hagyományos mobilhálózatnak (2G, GSM)
 és a kommunikációt biztosítja a mobiltelefon és a hálózati kapcsolóalrendszer
 között.
 A BSS transzkódolást végez, rádió csatornákat rendel a mobiltelefonokhoz,
 lapozást kezel, és még sok más feladatot ellát a rádiós hálózatban.
\end_layout

\begin_layout Description
BTS (Base Transceiver Station) tartalmazza a rádió szignálok átviteléhez
 és fogadásához szükséges berendezéseket, antennákat, valamint a bázisállomással
 (BSC) történő kommunikáció dekódoláshoz és titkosításhoz szükséges eszközöket.
 Valójában nem más, mint egy pikócella sok rádió adó-vevővel (TRX), amik
 lehetővé teszik különböző frekvenciák kiszolgálását.
 Egy BTS-t a "szülő
\begin_inset Quotes srd
\end_inset

 bázis állomás (BSC) vezérel.
\end_layout

\begin_layout Description
MS (Mobile Station) azaz maga a mobil készülék, amivel a felhasználó hívást
 kezdeményezhet és fogadhat.
 Ez a terminológia 2G rendszerekre vonatkozik, mint a GSM.
 3G rendszerekeben a mobile station helyett 
\begin_inset Quotes sld
\end_inset

user equipment
\begin_inset Quotes srd
\end_inset

-ként (UE) hivatkoznak rá.
\end_layout

\begin_layout Description
RNC (Radio Network Controller) az UMTS mobil hálózat (UTRAN) irányító egysége
 és a hozzá kapcsolt 
\begin_inset Quotes sld
\end_inset

Node B
\begin_inset Quotes srd
\end_inset

-k kontrollálásáért felelős.
 BSC-nek 3G-s hálózati megfelelője, hasonló munkát végez: az üzenetek encryptálá
sa és erőforrás kezelés.
 Az RNC kapcsolatban áll a Circuit Switched Core Network-hez a Media Gateway-en
 (MGW) keresztül és az Serving GPRS Support Node-en (SGSN) keresztül a Packet
 Switched Core Network-höz.
\end_layout

\begin_layout Description
Node-B Ezt a terminust az UMTS hálózatban használják és megfelel a BTS-nek
 a GSM-ben.
 A mobil készülékek Node B-n tudnak egymással kommunikálni.
 Az RNC kontrollálja ezt a hálózati elemet.
\end_layout

\begin_layout Description
VLR (Visitor Location Register) egy adatbázis azon előfizetők számára, akik
 beléptek az adott VLR-hez tartozó Mobile Switching Center (MSC) területére.
 Minden egyes bázisállomáshoz pontosan egy VLR tartozik, így az előfizető
 egy időben mindig csak egy VLR-ben szerepel.
 Az adatok vagy a mobil készülékről (MS), vagy a HLR-től érkeznek.
 Amint érzékel egy új MS-t az MSC, azonnal készít egy új bejegyzést a VLR-jében
 és frissíti a HLR-ben az előfizető helyzetét.
\end_layout

\begin_layout Description
HLR (Home Location Register) egy központi adatbázis, ami tartalmazza az
 összes mobiltelefon előfizetője adatát, akik használhatják hálózatot.
 
\end_layout

\begin_layout Description
M-MGW (Mobile Media Gateway) egy olyan eszköz, ami a digitális média folyamokat
 konvertálja (transzkódolja) a különböző telekommunikációs hálózatok között
 (PSTN, 2G, 3G, stb.), illetve lehetővé teszi a különféle átviteli protokollok
 használatát (ATM, IP, TDM) .
 Általában az egyes hálózatok határán helyezkedik el, hogy biztosítsa az
 adatok konvertálását egyik hálózatból a másikba.
\end_layout

\begin_layout Description
SGSN (Serving GPRS Support Node) felelős a mobileszközök és kiszolgáló állomások
 közötti adat csomagok szállításáért.
 A feladatai közé tartozik az irányítás (routing), a helymeghatározás és
 a felhasználók azonosítása (authentication).
 
\end_layout

\begin_layout Description
GGSN (Gateway GPRS Support Node) központi eleme a GPRS hálózatnak, az internet
 elérését biztosítja a GPRS hálózat és a külső hálózatok között.
 Kívülről nézve a GGSN egy router, aki elrejti a GPRS hálózat infrastruktúráját
 a külső hálózattól.
 Mikor adat csomagokat kap megvizsgálja, hogy a felhasználó aktív-e és,
 ha igen akkor továbbítja a csomagot az SGSN-nek, aki kiszolgálja a mobil
 felhasználót.
\end_layout

\begin_layout Description
MSC (Mobil Softswitch Controller) elsődleges eleme a GSM/CDMA hálózatoknak,
 a hanghívások route-olásáért és az SMS, valamint más szolgáltatásokért
 felelős, mint a konferencia hívások, FAX, stb.
 Kiépíti, majd lebontja a kapcsolatokat, hívásokat, valamint kezeli a handover-e
ket.
\end_layout

\begin_layout Description
IMS (IP Multimedia Subsystem) egy architektúra az IP alapú multimédiás szolgálta
tásokhoz.
 Kezdetben a 3GPP arra fejlesztette ki, hogy terjesszék ki a GPRS-t Internet
 alapú szolgáltatásokkal.
 A könnyebb integrálhatóság miatt IETF protokollokat használnak ahol csak
 lehetcségs, ilyen például a SIP (Session Initiation Protocol) .
\end_layout

\begin_layout Subsubsection*

\series bold
Mobil hálózat szolgáltatások
\end_layout

\begin_layout Standard

\series bold
SIM
\series default
 (Subscriber Identity Module) egyik fő jellemzője a GSM-nek a SIM bevezetése,
 a legtöbben SIM kártya néven ismerik.
 A SIM egy cserélhető okoskártya, mely az előfizető információt és telefonkönyve
t tartalmazhat.
 Lehetővé teszi a felhasználónak, hogy információkat tároljon és egy másik
 telefonban is fel tudja használni azokat.
 Ezentúl lehetővé teszi, hogy szolgáltatót váltson a felhasználó a készülék
 lecserélése nélkül, mivel csak SIM kártyát kell lecserélnie.
 Néhány operátor blokkolja ezt a lehetőséget a SIM lezárásával, ez esetben
 a készülék csak az adott szolgáltató kártyáját fogadja el.
\end_layout

\begin_layout Standard

\series bold
WAP
\series default
 (Wireless Application Protocol): egy sztenderd technika a vezetéknélküli
 hálózatokon keresztül történő információ cserének.
 A WAP böngésző egy webböngésző a mobil készülékekhez.
 A WAP bevezetése előtt, a mobil szolgáltatóknak limitált lehetőségük volt
 az interaktív adatszolgáltatásra.
 Interaktivitást követelt az Internet és Web alkalmazások támogatása pl.:
 email kezelés, tőzsdei árak vagy a sporteredmények követése.
 A WAP sztenderd egy protokoll családot ír le, mely lehetővé teszi az interopera
bilitást a WAP és más különböző hálózati technológiák között, mint a GSM
 és a CDMA.
\end_layout

\begin_layout Standard

\series bold
Roaming
\series default
 egy általános kifejezés a mobil szolgáltatás kiterjesztésére olyan helyre,
 amely különbözik a szolgáltatás regisztrált helyétől.
 Roaming biztosítja a kapcsolatot vezetéknélküli eszköz és a hálózat között,
 a kapcsolat elvesztése nélkül.
 Hagyományos GSM Roaming definició szerint (GSM Association Permanent Reference
 Document AA.39) a cella felhasználó képes automatikusan hívást indítani
 és fogadni, adatokat küldeni és fogadni, vagy más szolgáltatásokhoz kapcsolódni
, miközben utazik, elhagyja a hazai szolgáltatás által lefedett területet.
 
\end_layout

\begin_layout Standard

\series bold
Handover
\series default
 kifejezés (vagy handoff) arra a folyamatra utal, mikor egy folyamatban
 lévő hívást, vagy adat folyamot átviszünk az egyik csatornáról a másikra.
 Erre akkor van szükség, mikor a készülék átlépi a cella határát, vagyis
 kilép az eddigi adótorony körzetéből és egy másik veszi át a kiszolgálását.
 Több féle handover létezik, attól föggően, hogy a telefon melyik cellát,
 milyen irányba lépi át.
 Például abban az esetben, mikor a készülék nem csak egy celle határán van,
 hanem egy tartomány határán is, akkor nem csak egy másik toronyhoz (BTS
 vagy Node B) kerül át , hanem egy másik BSC vagy RNC-hez is.
\end_layout

\begin_layout Subsection
Mobilhálózatok fejlődése
\end_layout

\begin_layout Standard
Az első rádiótelefon szolgáltatás '40es végén vezették be Amerikában, ez
 azt jelentette, hogy a mobil használók akár autóból is tudtak kapcsolódni
 a meglévő publikus telefonhálózathoz.
 1960-ban új rendszert indított a Bell Systems, amit IMTS-nek (Improved
 Mobile Telephone Service) hívtak, mely számos újítást hozott, például szélesebb
 sávszélességet.
 Az első analóg cellás rendszer ezen az IMTS rendszeren alapult és a 1970-es
 évek elején fejlesztették ki.
 A rendszer "cellás" volt, mert a lefedett területeket felosztották kisebb
 részekre, avagy cellákra.
 
\end_layout

\begin_layout Subsubsection*

\series bold
Első generáció 
\end_layout

\begin_layout Standard
Első generációs mobil rendszer az AMPS (Advance mobile phone system), melyet
 először az Egyesült államokban vezették be.
 Ez az egyik legjobb FDMA (Frequency Division Multiple Access) technológia,
 mely lehetővé teszi, hogy hanghívást bonyolíthat az egész országban.
\end_layout

\begin_layout Subsubsection*

\series bold
Második generáció
\end_layout

\begin_layout Standard
2G digitális cellás rendszer, melyet az 1980-as évek végén fejlesztették
 ki.
 Az új rendszer jobb minőséget és nagyobb kapacitást biztosít a felhasználóknak
 az analóg 1G rendszerhez képest.
 GSM (Global system for mobile communication) volt az első kereskedelemben
 működtetett digitális cellás rendszer, mely TDMA (Time division multiple
 acces) alapú.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\paragraph_spacing single
\noindent
\align center
\begin_inset Graphics
	filename Gsm_structures.svg.jpg
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
2G hálózat struktúrája
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A 2G technológiák biztosítanak különböző szolgáltatásokat, mint szöveges
 üzenet, kép üzenet és MMS (multi media messages) küldését.
 Az összes szöveges üzenet digitálisan titkosított, így csak a megfelelő
 címzett tudja fogadni és elolvasni az üzenetet.
 Idővel sokat fejlesztettek a rendszeren, így alakult ki a korábban már
 említett GPRS és az EDGE technológiák.
 
\end_layout

\begin_layout Subsubsection

\series bold
Harmadik generáció
\series default
 
\end_layout

\begin_layout Standard
3G kezdeményezés a készülék gyártóktól származott, nem pedig a telefonhálózatok
 operátoraitól.
 A fejlesztés 1996-ban kezdődött a Nippon Telephone & Telegraph (NTT) és
 az Ericsson vezetésével; 1997-ben az amerikai Telecommunications Industry
 Association (TIA) a CDMA-t választotta 3G technológiájának; 1998-ban az
 European Telecommunications Standards Institute (ETSI) ugyan ezt tette
 és végül a széles sávú CDMA (W-CDMA) és a CDMA 2000 adaptálták az UMTS-hez
 (Universal Mobile Telecommunications System).
 W-CDMA és CDMA 2000 volt a két legnagyobb javaslat a 3G technológiára.
 A W-CDMA TDM-et (Time Division Multiplexing), ezzel ellentétben a CDMA
 2000 CDM-et (Code Division Multiplexing) eljárást használ.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename UMTS_structures.svg.jpg
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
3G hálózat struktúrája
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
3G rendszer gyorsabb kommunikációs szolgáltatást nyújt, beleértve a hang,
 fax és Internet szolgáltatásokat, melyek bármikor és bárhonnan elérhetőek.
 Az ITU féle IMT-2000 3G sztenderd tette lehetővé az innovatív applikációk,
 például multimédiás szorakoztatás, információ és helymeghatározás szolgáltatáso
k elterjedését a felhasználók között.
 Az első 3G hálózatot Japánban építették ki 2001-ben.
 2.5G hálózatok, mint a GPRS (Global Packet Radio Service) már elérhetőek
 voltak Europa bizonyos országaiban.
 3G technológia támogatja a 144 Kbps sávszélességet nagy sebességű mozgásnál
 (pl: járművek), 384 Kbps pl egyetemek területén és 2 Mbps-ot állóhelyzetben
 (pl: épületen belül).
 A maximális letöltési adatráta 384Kpbs, átlagosan 200 Kpbs és a feltöltés
 is ráta 64 Kpbs.
\end_layout

\begin_layout Subsubsection*

\series bold
Negyedik generáció 
\end_layout

\begin_layout Standard
Negyedik generációs (4G) mobil kommunikáció nagyobb adatátvitelre lesz képes,
 mint a 3G.
 Az adatráta tervezett mértéke 100 Mbps .
\end_layout

\begin_layout Standard
A 4G szolgáltatás biztosítani fogja a szélessávú, nagy kapacitású, nagy
 sebességű adatátvitelt, így lehetővé teszi többek között a jó minőségű,
 nagy felbontású videótelefonálást.
 A 2008-as ITU szabvány szerint legfeljebb 100 Mbit/s átviteli sebesség
 elérése lesz képes egy gyorsan mozgó készülék esetén (például: kocsiban,
 vonaton) és akár 1Gbit/s adatráta is elérhető egyéb esetekben.
 Két 4G rendszertervet dolgoztak ki, amit már kereskedelmi forgalmoban is
 használnak, ez a Mobile WiMAx és az LTE.
 Egyik megoldás sem telejesen teljesíti az ITU szabványt, ezért ezeket még
 
\begin_inset Quotes sld
\end_inset

hivatalosan
\begin_inset Quotes srd
\end_inset

 nem tartják a szakemberek negyedik generációs hálózatnak, habár az operátorok
 már annak hírdetik.
 Mindkét technológiát fejelsztik, hogy megfeleljen a 4G szabvány elverásainak,
 főleg az adatátviteli sebesség kapcsán.
 Egzáltalán nem támogatja már a hagzományos vonalkapcsolt szolgáltatásokat,
 csak az internet protokollra (IP) épülőket, mint amilyen az IP telefonálás.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename interphaseLTEnetwork.jpg
	scale 60

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
4G és 3G hálózat architektúrája
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
A hálózatok vizsgált adatai
\end_layout

\begin_layout Standard
A lenti táblázat tartalmazza az átvitelisebességeket különféle technológiák
 esetén.
 Ezek a sebesség adatok módosulhatnak attól függően, hogy milyen rádiótechnológi
át használ a telefonhálózat operátora (CDMA, FDD, stb.) Amint látható, a
 2G és 3G hálózatok adatrátája egyre inkább növekszik, így lehetővé téve
 a nagyobb sávszélességigényű szolgáltatások bevezetését, mint a HD audió
 és videó szolgáltatások.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="right" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Technológia
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Adatráta
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GSM
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9.6Kbps 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GSM/GPRS 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
40Kbps-144Kbps 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
EDGE 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
474Kbps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UMTS (WCDMA) 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
384Kbps-2Mbps 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CDMA-One 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9.6Kbps-76.8Kpbs
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CDMA 2000 1x EV-DO 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
384Kbps – 2.4Mbps 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CDMA 2000 1x EV-DV
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.09Mbps 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CDMA 2000 3x
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2Mbps – 4Mbps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HSDPA 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8Mbps – 10Mbps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LTE
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
le 1 Gbps, fel 500 Mbps.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Technológiák és az elérhető adatráták
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A hálózat további fontos tulajdonságai, amik mérésre kerülnek a jelerősség
 és UDP tesztek esetén a jitter.
 A jelerősség - amit dBm-be mérnek - indikálja a szolgáltataás minőségét.
 Az értéke sok paramétertől függ, többek között az adótoronztól való távolságtól
, a természeti akadájoktól, amik a készülék és a torony között vannak (erdő,
 hegy, stb.) és az időjárástól is függhet.
 A telefonkészüléken 5 darab kis osztás szokta jelezni a jelerősséget.
 Minél több osztás aktív, annál erősebb a jel, annál jobb a szolgáltatás.
 Ha kicsi a jel erősség, akkor probléma léphet fel a szolgáltatások minőségében,
 például akadozik a hangátvitel, nagyon ingadozik az átviteli sebesség.
 A ritkán lakott területeken is kicsi szokott lenni a jelerősség.
 A mérésekből kiderülhet, hogy olyan helyen is rossz a jel minősége, ahol
 ezt nem is várnánk, és az operátorok feladata, hogy kiderítsék ennek az
 okát.
\end_layout

\begin_layout Standard
A jitter a csomagok megérkezési ideje közötti különbség, amit a hálzati
 torlódásból, időzítési problémából vagy útvonal váltásból eredhet.
 Ez akkor jó, ha kicsi az érték, azaz a csomagok sűrűn követik egymást és
 a csomagok beérkezési idejei között nem nagy a különbség.
 A jitter nagysága, illetve nagy, sűrű változása okozhatja a telefonbeszélgetése
k közbeni hangkiesést, akadozást, illetve a videolejeátszás során a képek
 kiesését, szagatást.
 Az UDP-t használó tesztek során a jelentések tartalmazzák az aktuális jitter
 értéket.
 Ezen értékeket figyelve derülhet ki a magas jitter érték, illetve a gyakori,
 nagy különbségek is problémát jelezhetnek a hálózatban.
 
\end_layout

\begin_layout Section
Android platform bemutatása
\end_layout

\begin_layout Standard
Az Android fejlesztő környezet széleskörű támogatást nyújt a fejlesztőknek
 a telefon és a hálózat adatainak lekéréséhez, ami nagyban megkönnyíti az
 alkalmazás fejlesztését.
 A nyílt fejlesztői környezettel az Android lehetőséget biztosít a fejlesztőnek,
 hogy magas színvonalú és innovatív alkalmazásokat készítsen.
 A fejlesztők kihasználhatják például az adott eszköz hardver képességeit,
 hozzáférhetnek a felhasználó adataihoz és akár futtathatnak háttér szolgáltatás
okat is.
\end_layout

\begin_layout Subsection
Android komponensek
\end_layout

\begin_layout Standard
Az Android fejlesztőkörnyezetnek több komponense létezik, mindegyiknek különböző
 célja és szerepe van a programban.
 Ezek általában egymással szoros kapcsolatban állnak, de önálló példányban
 léteznek és saját életciklusuk van.
\end_layout

\begin_layout Subsubsection
Activity
\end_layout

\begin_layout Standard
Egy felhasználói felülettel rendelkező képernyőt, ablakot Activity-nek nevezünk.
 Például egy zenelejátszó program Activity-je lehet, ami megjeleníti a lejátszó
 felületet, és egy másik, ahol kiválaszthatja a felhasználó a lejátszandó
 zenéket.
 Minden alkalmazásnak van egy kitüntet "fő
\begin_inset Quotes srd
\end_inset

 Activity-je, ha a felhasználó elindítja a programot ez az ablak jelenik
 meg.
 Habár mindegyik Activity a zenelejátszó programban együttműködve adja a
 teljes felhasználói élményt, mégis mindegyik független a többitől.
 
\end_layout

\begin_layout Standard
A hagyományos applikációkkal ellentétben az Android programoknak nincs kontrollj
uk az életciklusuk felett.
 Így az alkalmazás komponenseinek figyelnie kell a program állapotváltozására
 és aszerint reagálni.
 A komponensek állapota befolyásolja a program állapotát, mely meghatározza
 a program prioritását a rendszerben.
 Az Activity-k úgynevezett "Activity stack
\begin_inset Quotes srd
\end_inset

-en, azaz egy Last-In-First-Out adatszerkezetben tárolódnak.
 Mikor egy új Activity elindul, az előtte futó kerül a stack tetejére.
 Ha az előtérben lévő, aktív Activity bezáródik vagy a felhasználó megnyomja
 a Vissza gombot, akkor a verem tetején lévő kerül előtérbe.
 Ha az Activity-t megsemmisíti a rendszer, mert már nincs rá szükség, akkor
 felszabadítja annak erőforrásait és eltávolítja a veremből.
 A folyamatot az alábbi kép szemlélteti.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename stack.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Activity-ket tartalmazó verem
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Az Activity-nek négy állapota lehet:
\end_layout

\begin_layout Itemize

\series bold
Aktív 
\series default
(Active), ebben az állapotban a verem tetején lévő Activity lehet, ilyenkor
 az ablak előtérben van és képes fogadni a felhasználói utasításokat.
 Az Android rendszer mindent megtesz annak érdekében, hogy ez az Activity
 futhasson.
 Így, ha kevés az erőforrás, a memória, akkor leállítja a verem alján lévőket
 és felszabadítja azok erőforrását.
 Mikor egy másik Activity lesz az aktív, akkor az előbbi állapota felfüggesztett
 lesz.
\end_layout

\begin_layout Itemize

\series bold
Felfüggesztett
\series default
 (Paused) állapotban az Activity látható maradhat, de nem reagál felhasználói
 eseményekre, nincs fókusza.
 Ez akkor fordulhat elő, ha az előtérben lévő ablak átlátszó vagy nem fedi
 le a teljes képernyőt.
 
\end_layout

\begin_layout Itemize

\series bold
Leállt 
\series default
(Stopped), ekkor az Activity nem látható, leállt.
 Az erőforrások még nem szabadulnak fel és a veremből sem kerül ki.
 A leállt Activity-k prioritása a legkisebb, így ezeket terminálja legelőször
 a rendszer, ha erőforrásra van szüksége.
\end_layout

\begin_layout Itemize

\series bold
Inaktív 
\series default
(Inactive) állapotba kerül, ha terminálva lett vagy mielőtt elindul.
 Ezek az Activity-k nincsenek a veremben és csak újraindításkor válhat aktívvá.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename activity_lifecycle.png
	scale 60
	clip

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Activity életciklusa
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Android rendszer biztosítja, hogy az egyes Activity-k reagálhassanak az
 állapotváltásra.
 A lenti képen láthatóak az Activity életciklusai.
 A téglalapok visszahívó (callback) metódusokat szimbolizálnak.
 Ezek felhasználhatók különféle műveletek végrehajtására az egyes átmenetek
 során.
\end_layout

\begin_layout Itemize

\series bold
onCreate() 
\series default
Az Activity létrejöttekor hívódik meg.
 Itt kell az összes statikus adatot inicializálni, például nézetek létrehozása.
 Ez a függvény kap egy Bundle típusú paramétert, mely az Activity előző
 állapotát tartalmazza.
 Mindenképp onStart() metódus hívás követi.
\end_layout

\begin_layout Itemize

\series bold
onRestart() 
\series default
egy leállított Activity újraindítása során hívódik meg.
 OnStart() metódus követi.
\end_layout

\begin_layout Itemize

\series bold
onStart() 
\series default
az előtt hívódik, hogy az Activity láthatóvá válna a felhasználó számára.
 OnResume() metódus hívódik ezután, ha az Activity előtérbe kerül vagy az
 onStop(), ha háttérbe kerül.
\end_layout

\begin_layout Itemize

\series bold
onResume() 
\series default
akkor hívódik, ha az Activity a verem tetejére kerül, mielőtt aktívvá válna
 és felhasználói inputot fogadna.
 Minden esetben onPause() hívódik utána.
\end_layout

\begin_layout Itemize

\series bold
onPause() 
\series default
egy másik alkalmazás folytatása váltja ki ezt a metódushívást.
 Itt célszerű elmenteni az adatokat, illetve leállítani az erőforrás igényes
 műveleteket, mint például az animáció lejátszást.
\end_layout

\begin_layout Itemize

\series bold
onStop() 
\series default
az Activity leállásakor vagy egy másik Activity aktívvá válásakor hívódik,
 ilyenkor Ezután onRestart() hívás jelzi, hogy újra aktívvá vált az Activity.
 
\end_layout

\begin_layout Itemize

\series bold
onDestroy() 
\series default
az Activity megszűnésekor kerül meghívásra, amit vagy a rendszer vált ki,
 mert erőforrásra van szüksége vagy meghívták rá az 
\shape italic
finish()
\shape default
 metódust.
\end_layout

\begin_layout Subsubsection*
Service 
\end_layout

\begin_layout Standard
A Service (szolgáltatás) egy háttérben, párhuzamosan futó komponens.
 Sokáig futó műveletek végrehajtására használható és nem biztosít felhasználói
 felületet.
 Ilyen művelet lehet például a zenelejátszás, miközben a felhasználó más
 alkalmazást használ, anélkül, hogy a háttérben futó zenelejátszás blokkolná
 vagy zavarná a másik alkalmazást, illetve a felhasználót.
 Egy másik komponens, mint például egy Activity indíthat Service-t és interakció
ba léphet vele.
 Egy új service-t indíthat egy komponens a 
\shape italic
startService()
\shape default
 metódus hívással, ami akkor is fut, ha a hívó komponens megszűnik.
 Service automatikusan leáll, ha a feladatát befejezte.
 Ez a feladat lehet például egy fájl feltöltése.
 Másik működési módja a service-nek az úgynevezett kötött (bound) service.
 Egy komponens a 
\shape italic
bindService()
\shape default
 metódussal tud összeköttetésbe kerülni ezzel service-vel.
 Több komponens is kapcsolódhat egy service-hez, ha már egy komponens se
 kapcsolódik a szolgáltatáshoz, akkor megszűnik a service.
 Fontos callback metódusok, melyeket implementálhat egy service -nek:
\end_layout

\begin_layout Itemize

\series bold
onStartCommand() 
\series default
akkor hívódik, mikor egy másik komponens meghívja a 
\shape italic
startService()
\shape default
 metódust.
 Ha ez a metódus implementálásra kerül és befejezte a működését, akkor a
 le kell állítani a 
\shape italic
stopSelf()
\shape default
 vagy 
\shape italic
stopService()
\shape default
 metódussal.
 Ha csak kötött szolgáltatásként szeretnénk használni , akkor nem kell implement
álni ezt a metódust.
\end_layout

\begin_layout Itemize

\series bold
onBind()
\series default
 metódus hívódik, ha egy másik komponens akar kapcsolódni a service-hez
 a 
\shape italic
bindService()
\shape default
 függvény hívással.
 Ha nem akarjuk megengedni a szolgáltatáshoz való csatlakozást akkor null-t
 kell visszatérő paraméterként, egyébként pedig egy IBinder típusú objektumot,
 amin keresztül a hívó komponens kommunikálhat a szolgáltatással.
\end_layout

\begin_layout Itemize

\series bold
onCreate()
\series default
 a service létrehozásakor hívódik az 
\shape italic
onStartCommand()
\shape default
 előtt.
\end_layout

\begin_layout Itemize

\series bold
onDestroy()
\series default
 a rendszer hívja ezt a metódust, mikor a szolgáltatást már nem használják
 többé és meg kell szüntetni.
 Itt kell felszabadítani a foglalt erőforrásokat, szálakat.
\end_layout

\begin_layout Subsubsection*
IntentService
\end_layout

\begin_layout Standard
Az IntentService a Service osztályból öröklődik és aszinkron kéréseket kezel
 (Intent-eken keresztül).
 Kliens külkd egy kérést a startService(Intent) híváson keresztül és a szolgálta
tás elindul, és leállítja magát, ha végre hajtotta a feladatát.
 Egyszerre csak egy kérést szolgál ki, ha több érkezik be, akkor egymás
 után lesznek kiszolgálva.
 Ez a módszer gyakran használt eljárás, annak érdekében, hogy tehermentesítsük
 az applikáció fő szálát.
 A használatához az IntentService osztályból kell származtatni és implementálni
 az 
\shape italic
onHandleIntent(Intent)
\shape default
 metódust.
 Az IntentService meg fogja kapni ezt az Intent-et, elindítja az új szálat,
 és megállítja szolgáltatást.
\end_layout

\begin_layout Subsubsection
Broadcast receiver
\end_layout

\begin_layout Standard
A broadcast receiver egy olyan komponens, amely válaszol a rendszerszintű
 üzenetekre.
 Számos rendszerüzenetet kezelhet például a képernyő kikapcsolásról vagy
 az akkumulátor töltöttségének csökkenéséről érkező üzeneteket.
 Az alkalmazás is kezdeményezhet ilyen üzenet küldést például, ha egy másik
 alkalmazásnak akar üzenetet küldeni.
 A service-hez hasonlóan nem rendelkezik felhasználói felülettel.
\end_layout

\begin_layout Standard
Az egyes komponenseket egy aszinkron üzenettel lehet aktiválni, amit Inetent-nek
 neveznek.
 Ez kapcsol össze komponenseket futási időben, akkor is, ha a komponens
 egy másik applikációhoz tartozik.
 Az Intent közvetíthet üzenetet másik komponensnek, például, hogy jelenítsenek
 meg egy képet vagy nyisson meg egy weboldalt.
\end_layout

\begin_layout Subsubsection*
Intent
\end_layout

\begin_layout Standard
Az intent üzenetekkel futás idejü kapcsolatot, kötést létesíthetünk Android
 komponensek között.
 Intent objektum egy adatstruktúra, ami általában a végrehajtandó művelet
 absztrakt leírását tartalmazza, illetve a fogadó komponens számára fontos
 információkat is tartalmazhat.
 Ezen felül tartalmaz a rendszer számár a lényeges információkat például:
 a fogadó komponens kategóriáját.
 
\end_layout

\begin_layout Subsubsection
Application 
\end_layout

\begin_layout Standard
Ezen osztály segítségével lehet figyelni, karbantartani az egész applikáció
 állapotát.
 A saját application obektumunkat az AndroidManifest.xml fájl <application>
 tagja írja le, ami azt jelenti, hogy az osztály példánya létrejön az applikáció
 indulása elején.
 Álatlában nincs szükség erre az objektumra.
 A többi Android obejktumból elérhető az Application objektum a 
\shape italic
getApplication()
\shape default
 metódus segítségével.
\end_layout

\begin_layout Standard
Ha szükség van egy globáls Context objektumra (például BroadcastReceiver
 objektum beregisztrálásához), itt található a 
\shape italic
getApplicationContext()
\shape default
 függvény, mely visszaadja ezt a Context objektumot.
\end_layout

\begin_layout Subsection
Futási környezet és konfigurációs fájlok
\end_layout

\begin_layout Standard
Az Android SDK tartalmaz egy alap könyvtárat, mely megvalósítja a Java programoz
ásinyelv túlnyomó részét.
 
\end_layout

\begin_layout Standard
Minden alkalmazás saját szálon fut és saját Dalvik virtuális gép példánnyal
 rendelkezik, így egymástól elkülönítve tudnak futni az egyes alkalmazások.
 A Dalvik VM (virtuális gép) a Linux kernelre támaszkodik az alacsony szintű
 funkcionalitás használata során, mint például a szálkezelés.
 A Linux továbbá biztonsági, memória és hálózat kezelési szolgáltatásokat
 is nyújt.
\end_layout

\begin_layout Standard
Az Android operációs rendszer megvalósítja a 
\shape italic
legkisebb jogosultság elvét, 
\shape default
így az alkalmazás csak a számára szükséges komponensekhez fér hozzá.
 Egy alkalmazás engedélyt kérhet arra, hogy komponensekhez, adatokhoz férhessen
 hozzá például: névjegyzék, tárolók (SD kártya), kamera, stb.
 Minden engedélyt a felhasználónak kell jóváhagynia telepítéskor.
\end_layout

\begin_layout Subsubsection
AndroidManifest.xml
\end_layout

\begin_layout Standard
Az Android rendszer számára szükséges konfigurációs paramétereket tartalmazza,
 illetve az alkalmazás által használt komponensek deklarációját.
 Tartalmazza továbbá a felhasználói jogosultságok listáját, deklarálja az
 alkalmazás futtatásához szükséges minimum Android API szint számát, illetve
 egyéb hardver és szoftver paramétereket.
 Azok a komponensek, amik nincsenek deklarálva ebben a fájlban, nem láthatóak
 a rendszer számára.
 Ez a fájl az alkalmazás gyökérkönyvtárában foglal helyet.
\end_layout

\begin_layout Standard
így néz ki egy Activity deklarációja a manifest fájlban:
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset External
	template JavaCode
	filename manifest.java

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Az <activity> elemben az android:name paraméter tartalmazza az Activity
 osztályból származó osztály nevét, melyet az alkalmazásban használunk.
 Az android:label paraméterben megadhatjuk a felhasználó számára megjelenő
 nevet.
\end_layout

\begin_layout Standard
A fenti példában látható <intent-filter> rész utasítja a rendszert, hogy
 a MainActivity nevű acvtivity objektumot töltse be az alakalmazás elindulása
 után.
\end_layout

\begin_layout Standard
Komponensek deklarációja a manifest fájlban a következők lehetnek:
\end_layout

\begin_layout Itemize
<activity> elemek az Activity-ból származó osztályokhoz
\end_layout

\begin_layout Itemize
<service> elemek a Service illetve IntentService típusú osztályokhoz
\end_layout

\begin_layout Itemize
<receiver> elemek a BroadcastReceiver osztályokhoz
\end_layout

\begin_layout Itemize
<provider> elemek a tartalomszolgáltató osztályokhoz
\end_layout

\begin_layout Subsubsection
Felhasználói felület leírása
\end_layout

\begin_layout Standard
Az Android rendszerben az Activity objektumok rendelkeznek felhasználói
 felülettel, melyek leírását objektumonként külön-külön kell deklarálni
 XML fájlokban.
 Ezek a fájlok az alkalmazás könyvtárán belül a 
\shape italic

\begin_inset Quotes sld
\end_inset

res/layout
\begin_inset Quotes srd
\end_inset


\shape default
 könyvtárban találhatóak.
 Egy XML elem neve ebben az esetben egy Java objektum nevét tükrözi, tehát
 ha az XML elem egy <Button> elem, akkor az alkalmazás egy Button (gomb)
 objektumot fog létrehozni.
 Amikor betöltődik egy Activity objektum, akkor a neki megfelelő felület
 leíró XML fájlból a rendszer megfelelően létrehozza futási időben és inicializá
lja ezeket az objektumokat.
 
\end_layout

\begin_layout Standard
Példa egy egyszerű függőleges elrendezés egy szövegmezővel és egy gombbal:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<?xml version="1.0" encoding="utf-8"?>
\end_layout

\begin_layout Plain Layout

<LinearLayout xmlns:android="http://schemas..."
\end_layout

\begin_layout Plain Layout

    android:layout_width="match_parent"
\end_layout

\begin_layout Plain Layout

    android:layout_height="match_parent"
\end_layout

\begin_layout Plain Layout

    android:orientation="vertical" >
\end_layout

\begin_layout Plain Layout

	<TextView android:id="@+id/textView1"
\end_layout

\begin_layout Plain Layout

		      android:layout_width="wrap_content"
\end_layout

\begin_layout Plain Layout

      		android:layout_height="wrap_content"
\end_layout

\begin_layout Plain Layout

      		android:text="" />
\end_layout

\begin_layout Plain Layout

    <Button android:id="@+id/button1"
\end_layout

\begin_layout Plain Layout

            android:layout_width="wrap_content"
\end_layout

\begin_layout Plain Layout

            android:layout_height="wrap_content"/>
\end_layout

\begin_layout Plain Layout

</LinearLayout>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ezeket a leíró fájlokat könnyedén kézzel is szerkeszthetjük vagy akár az
 Eclipse fejlesztőeszközbe ágyazott grafikus szerkesztőfelület segítségével
 is.
 Különféle Layout objektumok segítségével meghatározhatjuk az egyes elemek
 (gombok, szövegmezők, stb.) elhelyezkedését.
 A felhasználóval való interakciókra különféle elemek állnak rendelkezésre
 pl.: gombok, beviteli mezők, dátumválasztók, stb.
 ezeket widget-eknek nevezzük.
 A felhasználói felület (UI - user interface) leíró XML fájlokban hozzá
 tudunk rendelni különféle elemekhez visszahívó (callback) metódusokat.
 Ezeket az XML elemek android:on<valami> (pl.: android:onClick=<metódus_név>)
 paraméterében tudjuk meghatározni.
 A felhasználói felületet leíró fájlt használó Activity osztályban kell
 definiálni az XML elemekhez tartozó visszahívó metódusokat, melyek meghívódnak,
 ha az adott eseményt kiváltja egy felhasználói esemény.
 
\end_layout

\begin_layout Subsubsection
Menü leírása
\end_layout

\begin_layout Standard
Menüket külön leíró XML fájl(ok)ban definiálhatunk, melyekben meg kell határozni
 az egyes menüpontokat.
 Ezen leíró fájlok a program könyvtárán belül a 
\begin_inset Quotes sld
\end_inset

res/menu
\begin_inset Quotes srd
\end_inset

 mappában találhatóak.
 A felhasználó a menün keresztül navigálhat a user interface-el rendelkező
 Activity-k között és elérheti a beállításokat.
 Az Activity osztályokhoz az onCreateoptionMenu metódus megvalósításával
 tudunk menüt rendleni.
 Itt kell megadni, hogy mi történjen, ha a felhasználó az egyes menüpontokra
 kattint.
 Az Android rendszer automatikusan kirajzolja a menüt a képernyőre.
\end_layout

\begin_layout Subsubsection*
Adattárolás
\end_layout

\begin_layout Standard
Az Android számos lehetőséget kínál az adatok perzisztens tárolására.
 Ezek lehetnek megosztott preferenciák (Shared preference), mely primitív
 adatokat tarol kulcs-érték párok alapján, külső illetve belső tároló, illetve
 SQLite adatbázis.
 
\end_layout

\begin_layout Standard

\series bold
Megosztott preferenciák
\series default
 segítségével tárolhatjuk el egyszerűen az alakalmazás, illetve az egyes
 Activity objektumok állapotát, mivel az adatok megmaradnak az alakalmazás
 megszünése után is.
 Kulcs-érték párok segítségével el tudjuk menteni az objektumok változóinak
 értékét, majd visszaolvasni, ha szükséges.
 Az eltárolt attribútumok float, int, long, boolean és string típusúak lehetnek.
 A 
\shape italic
getSharedPreferences()
\shape default
 metódus segítségével névvel ellátott preferenciát kapunk, melyet első paraméter
ként kell megadnunk, és arra hivatkozva bárhonnan el tudjuk érni az alaklamzásbó
l.
 A 
\shape italic
getPreferences()
\shape default
 függvény segítségével az Activity objektumokhoz rendelhetünk egy preferenciát,
 amiben az adott tevékenység objektum adatait tárolhatjuk.
 
\end_layout

\begin_layout Standard

\series bold
Belső tár 
\series default
segítségével
\series bold
 
\series default
olyan fájlokat hozhatunk létre a telefonkészülék belső, nem hordozható memóriájá
ban, amikhez csak az alakalmazás férhet hozzá és annak eltávolításakor ezek
 a fájlok automatikusan törlődnek.
 
\end_layout

\begin_layout Standard
A 
\series bold
külső tár
\series default
 lehet a telefonhoz csatolt SD kártya, azaz hordozható memória egység, melyen
 olyan fájlokat tárolhatunk, melyekhez a felhasználó is hozzáférhet.
 
\end_layout

\begin_layout Standard
Android alkalmazásokban SQLite 
\series bold
adatbázisok
\series default
at hozhatunk létre, melyek név szerint minden komponensből elérhetőek, de
 más applikációból már nem.
 Az SQLite támogatja a hagyományos relációs adatbázis funkciókat, mint az
 SQL szintaxis és tranzakciók.
 A futás során az adatbázisnak kevés memóriára van szüksége (kb.
 250 KByte).
 Az adatbázisműveletek fájl műveleteket igénzelnek, amik lassúak lehetnek,
 ezért aszinkron módon kell azokat végrehajtani.
 Adatbáziskezelés megvalósításához szükség lesz egy osztályra, mely az 
\shape italic
SQLiteOpenHelper 
\shape default
osztályból számrazik.
 Ennek az 
\shape italic
onCreate() 
\shape default
függvényét kell felüldefinálni az adatbázist létrhozó implementácioval,
 melyet SQL parancsal adhatunk meg.
 Az 
\shape italic
onUpgrade()
\shape default
 metódus felüldefiniálásával megadhatjuk a programunk, milyen utasításokat
 hajtson végre, ha a tábla korábbi verziója már létezik az adott eszközön.
 A helper osztályunk 
\shape italic
getReadableDatabase()
\shape default
 és a 
\shape italic
getWriteableDatabase()
\shape default
 függvényeinek segítségével kaphatunk egy SQLiteDatabase obejktumot, melyen
 keresztül hozzáférhetünk az adatbázis táblákhoz és módosíthatjuk azokat.
 SQLiteDatabase 
\shape italic
query()
\shape default
 és 
\shape italic
rawquary()
\shape default
 metódusaival futtathatunk lekérdezéseket.
 Minden lekérdezés egy Cursor objektumot ad vissza, mely segítségével manőverezh
etünk a lekérdezés eredményének sorai között.
 
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset External
	template JavaCode
	filename test.java

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Hálózati protokollok a programban
\end_layout

\begin_layout Description

\series bold
UDP (User Datagram Protocol): 
\series default
kapcsolatnélküli, megbízhatatlan csomagtovábbítást nyújtó protokoll.
 Portszámot és checksum-ot is tartalmaz egy csomag.
 A csomagok nem biztos, hogy ugyanabban a sorrendben érkeznek meg a fogadóhoz,
 mint amilyen sorrendben el lettek küldve.
 A küldő nem kap visszaigazolást a csomag megérkezéséről.
 Ez a protokoll nagyon elterjedt a videójátékoknál és a telekommunikációban.
 
\end_layout

\begin_layout Description

\series bold
TCP (Transmission Control Protocol): 
\series default
megbízható de ezért lassabb is, mint például az UDP.
 Folyamként vagy fájlként kezeli a kapcsolatokat.
 A csomagok megfelelő sorrendjéről, illetve az elveszett csomagok újra küldésérő
l is gondoskodik.
 A csomagok bufferrelésével eléri, hogy az átviteli sebesség is közel állandó
 legyen az adat küldése, továbbítása során.
\end_layout

\begin_layout Description

\series bold
HTTP (Hypertext Transfer Protocol):
\series default
 a web hálózati protokollja, fájlok és más adatok - azaz erőforrások - továbbítá
sára használják.
 Ezek az erőforrások lehetnek HTML fájlok, képek, lekérdezési eredmények,
 stb.
 Használhat TCP és UDP protokollokat is.
 HTTP a kliens-szerver modellt használja, vagyis a HTTP kliens megnyitja
 a kapcoslatot és küld egy kérést a HTTP szervernek.
 Amint a szerver visszaküldte a választ lezérja a kapcsolatot.
 A HTTP üzenet felépítését tekintve egy kérés vagy válasz sorral kezdődik
 pl.: 
\begin_inset Quotes sld
\end_inset

GET /path/to/file/index.html HTTP/1.0
\begin_inset Quotes srd
\end_inset

 vagy 
\begin_inset Quotes sld
\end_inset

HTTP/1.0 200 OK
\begin_inset Quotes srd
\end_inset

.
 A GET HTTP metódussal kérhetünk el egy erőforrást a szervertől, további
 metódusok még a POST és a HEAD.
 Ez után az erőforrás neve, címe szerepel majd a HTTP verzió.
 Válasz esetében csak a HTTP verzió és a státusz kód szerepel.
 Ezek után szerepelhetnek paraméterek 
\begin_inset Quotes sld
\end_inset

PARAMÉTER: érték
\begin_inset Quotes srd
\end_inset

 alakban.
 Itt szerepelhet a szerver, illetve a kliens számra fontos információk,
 mint például az erőforrás módosításának ideje: 
\begin_inset Quotes sld
\end_inset

Last-Modified: Fri, 31 Dec 1999 23:59:59 GMT
\begin_inset Quotes srd
\end_inset

.
 Válasz üzenetek esetén a kért erőforrás az üzenet végén szerepel.
 Ebben az esetben a Paraméterek között szerepel az üzenet hossza és típusa.
 
\end_layout

\begin_layout Description
HTTP* egy specializált HTTP protokolt, melyet a ebben a programban használok
 az Android applikáció és a szerveren futó alkalamazás kommunikációjában.
\end_layout

\begin_layout Section
A program architektúrája
\end_layout

\begin_layout Standard
A szerver oldali és a mobil alaklamazás is használja a 
\shape italic
HttpFileHandler.jar
\shape default
 fájlt, ami tartalmazza a közösen használt osztályokat.
 Ezen osztályok nagy része a tesztek futtatásában játszik szerepet.
\end_layout

\begin_layout Subsection
Szerver oldal
\end_layout

\begin_layout Subsection
Kliens oldal
\end_layout

\begin_layout Subsection
Adatbázis leírása
\end_layout

\begin_layout Standard
A program által használt adatbázis modell bemutatása, mezők jellemzése
\end_layout

\begin_layout Standard
Az applikáció adatbázisa a mobileszközön ebben a fájlban tárolódik: DATA/data/Dr
iveTesting/databases/FILENAME.
\end_layout

\begin_layout Subsection
Felhasználó felület terve
\end_layout

\begin_layout Standard
áttekintő ábra, amely mutatja a képernyők közti navigálási lehetőségeket,
 irányokat.
 Kiemelve a fontosabb felhasználói eseménykezeléseket
\end_layout

\begin_layout Section
A program megvalósítása
\end_layout

\begin_layout Subsection
Döntések a megvalósítás során
\end_layout

\begin_layout Standard
Ide kerül annak a leírása, hogy miért nem lettek megvalósítva a hívás indításos
 mérések; A több szálúság szükségessége és a komponensek kommunikációjának
 miértjei
\end_layout

\begin_layout Standard
A hálózati forgalom mérésére, figyelésére használtam volna a TrafficStats
 osztályt, ez egy Android API által biztosított osztály, mely a hálózati
 forgalomról nyújt információkat a /proc/uid_stat/<uid> könyvtárból.
 Ez tartalmazza a TCP vagy UDP protokollokon küldött és fogadott byte-ok
 és csomagok számát.
 Ha a fájlok nem léteznek aTrafficStats nem tud nhálózati statisztikával
 szolgálni.
 A getUidTxBytes() és a getUIDRxBytes() jelentések csak a TCP forgalmat
 tartalmazzák az UDP-re vonatkozót nem.
 Így az UDP forgalomról az alkalmazás nem kap semmilyen adatot.
 Ezen és hasonló hiábák miatt, nem tudtam érdemben használni a küldött és
 fogadott csomagok mérésére.
 Ezért saját csomag figyelő és számoló algoritmust kellett írjak.
 
\end_layout

\begin_layout Subsection
Osztályok bemutatása
\end_layout

\begin_layout Subsubsection
Közös osztályok
\end_layout

\begin_layout Standard
A közösen használt és a teszteléssel összefüggő osztályok a HttpTestHandler
 projekt tartalmazza.
 Ezen osztályok és interfészek tisztán Java alapúak, nem tartalmaznak Android
 specifikus megoldásokat, ezért használhatóak a szerver oldali programban
 is.
 
\end_layout

\begin_layout Description
ConnectionInstance megvalósítja a Java 
\shape italic
Callable 
\shape default
interfészt.
 Ez szolgál ősosztályként a TCP és UDP sender és receiver osztályoknak.
\end_layout

\begin_layout Description
HttpParser a HTTP üzenetek feldolgozását végzi.
 A 
\shape italic
parseHttpMessage
\shape default
 metódusnak kell átadni az üzenetet és a függvény true (igaz) értékkel tér
 vissza, ha sikeres volt a feldolgozás.
 Egyébként az üzenet szintaktikai vagy szemantikai hibás, amitől nem tudja
 értelmezni a paraméterként kapott szöveget.
 A feldolgozott értékek Java 
\shape italic
Properties
\shape default
 típusú attribútumaiban tárolódnak.
 A 
\shape italic
methodProperty
\shape default
 tartalmazza az üzenet típusát, egy paramétert, ami a buffer méretét adja
 meg vagy egy azonosítót tartalmaz és a HTTP verziót.
 A 
\shape italic
headerProperty 
\shape default
pedig az opcionális paramétereket tartalmazza, ezek a tesztek paramétereit
 írja le: a 
\begin_inset Quotes sld
\end_inset

MODE
\begin_inset Quotes srd
\end_inset

 az adatforgalom irányát határozza meg, hogy a syerver küldi-e az adatokat
 (ez a letöltés, 
\begin_inset Quotes sld
\end_inset

DL
\begin_inset Quotes srd
\end_inset

), vagy a mobiltelefon (ez a feltöltés, 
\begin_inset Quotes sld
\end_inset

UL
\begin_inset Quotes srd
\end_inset

).
 A másik paraméter a 
\begin_inset Quotes sld
\end_inset

CONNECTION
\begin_inset Quotes srd
\end_inset

 a kapcsolat típusát határozza meg, miszerint UDP, vagz TCP protokollt fog
 használni a teszt.
\end_layout

\begin_layout Description
Logger osztály segítségével különféle üzeneteket menthetünk el egy fájlba.
 A programban főleg a hibaüzeneteket eltárolásásra használom, ami a hiba
 keresésést könnyíti meg.
 Az üzenet a sztenderd kimenetre is kiiratható a 
\shape italic
addLineAndPrint 
\shape default
metódus segítségével.
 Ez utóbbit szerver oldali komponensben használható ki, mert ott a parancsorban
 is olvashatóak ezek az üzenetek.
 A log fájl nevét a konstruktorban adhatjuk meg, alapértelmezetten 
\begin_inset Quotes sld
\end_inset

log.txt" névvel fog létrejönni a fájl a bináris fájl mellett.
 Az addLine metódus hívásával az átadott szöveg ki fog íródni a fájlba és
 az elejére egy időbélyeg kerül.
\end_layout

\begin_layout Description
MessageI egy interfész, ami egyetlen sendReportMessage függgvény fejlécét
 tartalmazza.
 Ennek segítségével tud a TCPSender és UDPSender osztály jelentéseket küldeni
 - a ReportSender osztályon keresztül - a teszt és a csomagok állapotáról
 a ReportReceiver osztály egy példányának.
\end_layout

\begin_layout Description
ReceiverReportI a ReportReceiver osztály interfésze, melyet jelentések küldésére
 használ.
 Külön metódus tartozik a TCP és UDP teszthez kapcsolódó jelentéshez.
 
\end_layout

\begin_layout Description
ReportI interfészt megvalósítja a HttpService osztály és segítségével tud
 a ReportReceiver osztály példánya üzenetet továbbitani, illetve küldeni
 a Test Activity felé a felhasználónak.
 A 
\shape italic
sendMessage
\shape default
 metódussal lehet üzenetet küldeni.
\end_layout

\begin_layout Description
ReportReceiver osztály példánya a mobilkészüléken fut - egy külön szálon
 - és fogadja a jelentéseket, riportokat, majd továbbítja a HttpService
 példánynak, ami továbbitja a TestActivitynek az Application obejktumon
 keresztül.
 Így láthatóvá válik és folyamatosan frussül a TestActivity üzenetlistája.
 A TCP- és UDPReceiver osztályoktól kapott értékek a 
\shape italic
ReceiverReportI
\shape default
 interfészen keresztül a 
\shape italic
setReceivedBytes 
\shape default
metódus segítségével továbbítódnak, ha a receiver (fogadó) osztálypéldányok
 a mobil alakalmazáson futnak - azaz a mobilkészülék a fogadó-, így a mobil
 letöltési sebessségét vizsgljuk.
 Egyébként a szerver által fogadott csomagokról a ReportSender osztálytól
 kap üzenetet, amit a 
\shape italic
receiveReport
\shape default
 függvényben található Scanner objektum vár és olvas be.
 A 
\shape italic
parseReport
\shape default
 és 
\shape italic
checkProperty 
\shape default
metódusok értelmezik a kapott üzenetet és küldenek jelentést a HttpService-nek
 a ReportI interfészen keresztül, ahogy a korábban említett 
\shape italic
setReceivedBytes 
\shape default
függvény
\shape italic
.
 
\shape default
A sebesség adatok is itt kerülnek kiszámolásra a 
\shape italic
calcSpeed
\shape default
 függvényben.
 
\end_layout

\begin_layout Description
ReportSender a szerver oldali programban fut az osztály egy példánya, külön
 szálon.
 A megadott porton létrehoz egy ServerSocket-et, ahova a kliens oldalon
 futó ReportReceiver osztálypéldánya tud csatlakozni.
 Ezen keresztül kap értesítést a kliens a szerver oldali csomagok érekzéséről,
 a teszt állapotáról.
 A 
\shape italic
sendReportMessage
\shape default
 függvény segítségével küld HTTP üzenetet, ami tartalmazza a jelentés paramétere
it.
 
\end_layout

\begin_layout Description
TCPReceiver fogadja a TCP típusú teszt során a TCP csomagokat és számolja
 a kapott üzeneteket, azok méretét és erről jelentést küld egy előre megadott
 időintervallumonként, ezt a 
\shape italic
setReportInterval
\shape default
 függvény segítségével lehet megadni.
 A 
\shape italic
TimerTask 
\shape default
osztály segítségével lehet meghatározni, hogy milyen művelet hajtódjon végre
 az időzítő lejártakor.
 Az időzítést a Timer osztály 
\shape italic
scheduleAtFixedRate
\shape default
 metódusával lehet megadni.
 Az osztály konstuktora képes MessageI és ReceiverReportI interfészeket
 fogadni attól függően, hogy szerver oldalon fut - így a ReportSenderen
 keresztűl tud jelentést küldeni-, vagy a mobil oldalon, amikor a ReportReceiver
 osztály példányát használja.
 A 
\shape italic
setSocket 
\shape default
segítségével állítható be a socket, amin keresztül érkeznek majd az adatok,
 üzenetek.
 A 
\shape italic
readPackets
\shape default
 végzi az üzenetek figyelését és kiolvassa az InputStream objektum segítségével
 a kapott adatokat.
 A 
\shape italic
totalReadedBytes
\shape default
 változó tartalmazza az eddig fogadott adatok mennyiségét byte-ban.
 A ConnectionInstance osztály leszármazottjaként tartalmaz egy stop metódust
 is, ami a teszt leállításakor hívódik meg és leállítja az időzítőt és a
 socket-et.
\end_layout

\begin_layout Description
TCPReport a TCP teszt mérési eredményeinek eltárolására szolgál.
 Tartalmazza: a reporter objektum azonosítóját, a jelentés intervallumát,
 az átvitt adatokat és a le- vagy feltöltési sebességet.
 tartalmaz egy parseReport függvényt , mely egy String objektumot elemez
 és feltölti a kiolvasott értékekkel a riport paramétereket.
 A jelentés paraméterek a 
\shape italic
toString 
\shape default
metódus felüldefiniálásával szöveggé konvertálhatóak.
\end_layout

\begin_layout Description
TCPSender a ConnectionInstance osztályből származik és a konstruktorában
 megadott méretű buffert tölt fel véletlenszerü adatokkal.
 A buffer adatát foylamatosan küldi a 
\shape italic
setSocket
\shape default
 függvényen keresztül megadott socket-en keresztül egy OutputStream objektum
 segítségével.
 A küldést addig folytatja, amíg a 
\shape italic
stop
\shape default
 metódusát meghívva le nem állítjuk, ami leyárja a socket objektumot.
\end_layout

\begin_layout Description
UDPReceiver fogadja a UDP típusú teszt során a csomagokat és számolja a
 kapott üzenetek méretét, figyeli a csomagok sorrendjét és az elveszett
 csomagokat is számolja.
 Erről jelentést küld előre megadott idő intervallumonként, ezt a 
\shape italic
reportInterval
\shape default
 paraméter lehet megadni az osztály konstruktorában.
 Az UDP protokollt használó tesztek során nem épül ki tartós kapcsolat a
 kliens és a szerver között, ezért nem kap Socket objektumot, hanem maga
 az UDP teszt osztály építi ki magának a kapcsolatot.
 Az UDP protokoll történő üzenetküldéshez a Java DatagramSocket és DatagramPacke
t osztályait használom.
 A mobilhálózatokban előforduló NAT-olás miatt a kommunikációt minden esetben
 a mobil oldali osztálynak kell kezdeményeznie, így nyitva egy portot, amin
 keresztül ezután a szerver képes üzenetet küldeni a mobilkészüléknek.
 A mobil oldalon való futtatáskor a 
\shape italic
setSenderParameters 
\shape default
metódust használom, ami megkapja a server IP címét, a tesztáltal használni
 kívánt port számot és létrehoz egy alapértelmezett Datagramsocketet.
 Ezt a szál 
\shape italic
start 
\shape default
metódusának meghívása elött kell meghívni.
 A 
\shape italic
start
\shape default
 meghívása után az osztály 
\shape italic
call 
\shape default
függvényébe kerül át a vezérlés, ami leellenőrzi, hogy be van-e állítva
 a 
\shape italic
senderAddress 
\shape default
paraméter - vagyis a szerver IP címe -, ha igen, akkor meghyvja a 
\shape italic
sendAddressToSenderThroughNAT
\shape default
 függvényt.
 Ez arra szolgál, hogy küld egy DtagramPacketet a szerver címével és port
 számával a DatagramSoceket-en keresztül és vár egy válasz üzenetet.
 A riportolás a TCPReceiver-hez hasonlóan történik, annyi különbséggel,
 hogy itt több adatot küld át.
 Ezután a call metódus folyamatosan vár bufferSize méretü DatagramPacketeket.
 Számolja ezek sorszámát és fiegyeli az elveszett illetve rossz sorrendbe
 érkező csomagokat és számolja az aktuális jitter értéket a 
\shape italic
parsePackage
\shape default
 függvényben.
 A jitter érték számítás képletét az RFC 1889, Real Time Protocol (RTP)
 dokumentum tartalmazza.
 A 
\shape italic
lost
\shape default
 paraméter tartalmazza az elveszett, a 
\shape italic
cntOutofOrder
\shape default
 attribútum a felcserélődött csomagok számát tárolja, a 
\shape italic
sum
\shape default
 pedig az összes fogadott csomagszámát.
 
\end_layout

\begin_layout Description
UDPReport a TCPReport leszámrazottja, mely tartalmazza a UDP tesztek sajátos
 paramétereit: az elveszett csomagok számát, a felcserélődött csomagok számát,
 az össz csomag számot és a jittert.
 
\end_layout

\begin_layout Description
UDPSender
\end_layout

\begin_layout Description
Utility
\end_layout

\begin_layout Subsubsection
Szerver oldal osztályai
\end_layout

\begin_layout Description
HttpServer a szerver oldali lakalmazás fő osztálya.
 Ez tartalmazza a 
\shape italic
main
\shape default
 metódust, ami az alkalmazás belépési pontja.
 Az indulása után létrehoz egy 
\shape italic
ServerSocket
\shape default
 objektumot és az előre definiált 4500 porton vár a kliens (mobilegység)
 csatlakozására.
 A ServerSocket accept metódusa blokkolja a futást, amíg nem kapcsolódik
 a kliens, amint ez megtörtént létrhoz egy úh szálat (Thread), amiben a
 ServerThread osztály egy példánya fog futni.
 Jelen állapotában csak egy mobilt tud kisozlgálni az opsztály, de könnyedén
 modosítható, hogy több eszközt is ki tudjon sozlgálni.
\end_layout

\begin_layout Description
ServerThread osztály szolgálja ki a klienstől érkező kéréseket.
 A HttpServertől kapott socket-en keresztül fognak érkezni a klienstől a
 kérések, ezek kezelésére kell egy Scanner objketum, amit a konstruktorba
 hozok létre a socket 
\shape italic
getInputStream()
\shape default
 metódusának segítségével.
 A válaszok küldésére egy PrintWriter objektumot használok.
 A Java
\shape italic
Thread
\shape default
(szál) osztályának leszármazottjaként megörökli a 
\shape italic
run
\shape default
 metódust, amit felüldefinál.
 Az ott leírt parancsok futnak a szál objektumon meghívott 
\shape italic
start 
\shape default
függvény után.
 Az osztály a konstruktorában hívja meg saját magára a start függvényt.
 A kliens és a szerver HTTP*/1.0 protokol alapján kommunikálnak egymással.
 A kliens kezdeményezi a kommunikációt, így a 
\shape italic
run 
\shape default
metódus kezdetén megvárom a kliens üzenetét.
 Minden üzenetnek 
\begin_inset Quotes sld
\end_inset


\backslash
nEND" kell végződnie, addig fűzi össze soronként a klienstől kapott üzeneteket.
 Ezután a 
\shape italic
HttpParser
\shape default
 osztály 
\shape italic
parseHttpMessage 
\shape default
függvényének segítségével értelmezi a program az üzenetet.
 Két féle üzenetet fogad a szerver: az egyik a 
\begin_inset Quotes sld
\end_inset

GET
\begin_inset Quotes srd
\end_inset

 a másik pedig a 
\begin_inset Quotes sld
\end_inset

STOP
\begin_inset Quotes srd
\end_inset

, minden más esetben hibaüzenetet küld vissza a kliensnek válaszul.
 Az válaszüzenetet a 
\shape italic
sendResponse 
\shape default
metódus segítségével küldi ki az applikáció.
 GET üzenet esetén létrehozunk egy ServerSocketet-et a következő szabad
 portszámmal - ez 5500 és 5600 között vehet fel értéket- és 5 másodpercig
 vár, hogy a kliens oldalon indított teszt csatlakozzon hozzá, ezután a
 
\shape italic
makeTestHandlingThread
\shape default
 metódus ellenőrzi a kapott paramétereket és küld választ a kliensnek, mely
 tartalmazza a test port számát.
 Hiba esetén error üzenetet küld vissza a kliensnek.
 A kliens csatlakozása után inicializálódik a ReportSender objektum, későbbiekbe
n ezen keresztül tud jelentést küldeni a tesztről az applikáció.
 Végül a beállításoknak megfelelően létrejön és inicializálódik a megfelelő
 teszt osztály, amit egy 
\shape italic
ExecutorService
\shape default
 objektumba tároljuk, mely segítségével visszajelzést kaphatunk az aszinkron
 futó szálak befejeződéséről és visszatérés értékükről.
 A ExecutorService 
\shape italic
pool
\shape default
 metódusának hívsakor a szál futása is elkezdődik.
 STOP típusú üzenet akkor érkezik, mikor a felhasználó leállítja a tesztfuttatás
t.
 Ilyenkor az összes futó szál 
\shape italic
stop
\shape default
 metódusa meghívódik és leáll a futásuk, beleértve a 
\shape italic
report
\shape default
 osztályt is.
 
\end_layout

\begin_layout Subsubsection
Mobil alkalmazás osztályai
\end_layout

\begin_layout Description
GPSService Ez a szolgáltatás az Androidüos Service osztályból öröklődik
 és megvelósítja a LocationListener interfészt.
 A szolgáltatás indításakor az Application objektumban beállítódik, hogy
 fut a GPS szolgáltatás, majd az 
\shape italic
onStartCommand
\shape default
 metóduson keresztűl meghívódik a 
\shape italic
getLocation
\shape default
 függvény, ahol beregisztrálódik a GPSService osztály, mint LocationListener
 és így kap értesítést, ha változik a GPS pozíció, illetve, ha a szolgáltatás
 álllapotának változásáról is.
 Ehhez meg hívom a LocationManager Android osztály 
\shape italic
requestLocationUpdates
\shape default
 metódusát és utolsó paraméterként átadom a GPSService példányra mutató
 this pointert.
 A GPS koordináta változásakor a 
\shape italic
onLocationChanged
\shape default
 visszahívó metódussal kap értesítést a szolgáltatás.
 Ekkor a kapott Location paramétert továbbítja a DriveTestApp objektum felé.
 Az osztály megszűnésekor leiratkozik a pozíció frissítési szolgáltatásról.
\end_layout

\begin_layout Description
PhoneStateListenerService Az Android API által nyújtott dinamikus, időben
 változó telefon és hálózati információk lekérdezésére vonatkozó szolgáltatásoka
t valóstom meg itt.
 A 
\shape italic
connectivityReceiver
\shape default
 egy BroadcastReceiver, minek segítségével a ConnectivityManager üzeneteit
 megkapja az alaklamazás és így figyelhető a mobil internet szolgáltatás
 elérhetősége.
 A változásról értesül az application objektum is.
 A készülék és a hálózat adatairól a TelephonyManager segítségével kaphatunk
 információkat.
 PhoneStateListenerImpl segédosztály megvalósítja a PhoneStateListener interfész
t, így kap értesítést az applikáció az adatkapcsolat (data connection) állapotár
ól és a pozícióhoz kapcsoló MCC, MNC, LAC és CID paraméterekről is.
 Ezek az értékek az application objektumban lesznek letárolva.
 A PhoneStateListener a ConnectivityReceiverrel egyetemben a service konstruktor
ába kerül beregisztrálásra.
\end_layout

\begin_layout Description
The values are defined in the GSM standard TS 27.007, section 8.5 From the
 standard: 0 -113 dBm or less 1 -111 dBm 2...30 -109...
 -53 dBm 31 -51 dBm or greater 99 not known or not detectable Which means
 - 0 is low, 31 is good.
\end_layout

\begin_layout Description
HttpService Az alkalamazás egyik kulcs osztálya, nagy szerepe van a teszt
 futtatás során.
 A 
\shape italic
IntentService 
\shape default
osztályból származik, mely olyan szolgáltatás, ami csak addig fut amíg az
 
\shape italic
onHandleInstance
\shape default
 metódusában leírtak végrehajtódnak.
 
\end_layout

\begin_layout Description
DriveTestApp Ez az Application objektum, ez indul el legelőször a program
 futtatása során.
 Azon paraméterek tárolódnak itt, melyeket több Activity is használ.
 Itt történik az adatbázisba való irás is és azokat az adatokat, melyek
 nem a mérésből származnak (hálózat típúsa, jel erősség, stb) itt tárolódnak
 el.
 Továbbá eltárolódik a mobilnet és a GPS használatának be- vagy kikapcsolt
 állapota, ami a teszt futtatása előtt ellenőrzésre kerűl.
 Ezen információkat a megfelelő szolgáltatások adják, melyek korábban említésre
 kerültek.
 A DriveTestApp obejektum értesűl a változásokról a szolgáltatásoktól és
 értesíti a beregisztrált observer objektumokat.
 
\end_layout

\begin_layout Description
MainActivity Az alakalmazás fő (main) activity objektuma, vagyis ez az objektum
 töltődik be az alkaalmazás indulásakor és az ehhez tartozó felület fog
 megjelenni a képernyőn.
 A képernyőn megjelenő paraméter lista két fő részből tevődik össze.
 A telefon adataiból - ezek nagyrészt statikus adatok -, melyeket egyszer
 kérdez le az osztály a TelephonyManager segítségével, ezek a phoneDataList
 változóban tárolódnak.
 A másik rész pedig a mobil hálózatra vonatkozó információk, melyek dinamikusan
 változhatnak, ezen információkat a networkDataList változó tartalmazza.
 Ezek értékeit a PhonestateListenerService-től kapja az osztály.
 Ehhez megvalósítja a PhoneStateObserver interfészt és beregisztrálja magát
 az application objektumba, mint observer (megfigyelő) objektum: ((DriveTestApp)
getApplication()).registerPhoneStateObserver(this); A SimpleAdapter segítségével
 lehet táblázatos formába rendezni az adatokat, ehhez szükséges egy layout
 xml fájl, ami leírja az elrendezést.
 A két listához tartozó adapter neve phoneDataAdapter és networkDataAdapter.
 A 
\shape italic
setHashMapElement 
\shape default
metódus használatával adhatunk hozzá elemet a listákhoz, illetve módosíthatjuk
 egy bejegyzés értékét.
 A módosítást követően az adapter objektum 
\shape italic
notifyDataSetChanged
\shape default
 metódusával frssíthetjük a kijelzőn megjelenő listát.
 A SeparatedListAdapter segédosztály segítségével jeleníthetjük meg ezeket
 a listákat fejléccel, összefűzve.
 Ennek segítségével rendelhetünk különböző színt a lista soraihoz.
 Az osztály 
\shape italic
OnCreate 
\shape default
metódusában inicializálódnak a lista attribútumok az 
\shape italic
initPhoneData
\shape default
, illetve az 
\shape italic
initNetworkData
\shape default
 függvények segítségével.
 A TelephonzManager segítségével kiolvassuk a megfelelő értéket az állandó
 paraméterekhez, a változó értékekhez 
\begin_inset Quotes sld
\end_inset

-
\begin_inset Quotes srd
\end_inset

 jel írodik be, mely rögtön megváltozik, ha az adott paramétert érintő változás
 következik be.
 Az osztály OnPause esemény bekövetkeztekor aremovePhoneStateObserver metódus
 segítségével kitörölteti magát a PhoneStateObeserverek listájáról.
 Ez az esemény akkor következik, be mikor a felhasnzáló másik activityre
 vált át vagy bezárja az applikációt.
 Az OnResume esemény következik be, amint újra ez az activity kerül előtérbe.
 Iyenkor beregisztrálódik újra a PhoneStateObeserverek listájára és értesítést
 kap az értékek változásokról.
\end_layout

\begin_layout Description
TestActivity
\end_layout

\begin_layout Description

\series bold
Export Activity
\series default
 A program által generált teszt eredények fájlba menthetóek CSV formátumban
 ennek az Activity-nek a segítségével.
 A 
\begin_inset Quotes sld
\end_inset

Set Test Id
\begin_inset Quotes srd
\end_inset

 gombra kattintva a 
\shape italic
onTestClick 
\shape default
visszahívó metódus hívódik meg, ami megjelenití test azonosító választó
 felugróablakot.
 A test id-kat az adatbázisból kérdezi le a program a , majd egy AlarmDialog-on
 keresztűl megjelníti azokat.
 A 
\begin_inset Quotes sld
\end_inset

Export to CVS
\begin_inset Quotes srd
\end_inset

 felíratú gombra kattintva a 
\shape italic
onExportClick 
\shape default
metódus hajtódik végre, ahol leellenőrzi a program a beállított paramétereket,
 ha valamelyik nincs beállítva, akkor hibát jelez AlarmDialog segítségével.
 Az adatok a FileHandler osztály segítségével íródnak ki a külső vagy belső
 tárra.
 Ha elérhető (írásra is) a külső tár, akkor oda fog kerülni az fájl, különben
 a belső tárra.
 Az exportálás a fájlművelet miatt aszinkron folyamat, ami az AsyncTask
 osztály segítségével lett megvalósítva.
\end_layout

\begin_layout Description
PreferenceActivity
\end_layout

\begin_layout Subsection
Activity-k egymás közti kommunikációja
\end_layout

\begin_layout Standard
Az aszinkron működés kommunikációs megoldásainak leírása
\end_layout

\begin_layout Subsection
Fájlok kapcsolata
\end_layout

\begin_layout Standard
a projekt könyvtár szerkezetének és a fájlok szerepének bemutatása 
\end_layout

\begin_layout Section
Tesztelés
\end_layout

\begin_layout Standard
The first "Lint" program originated on Seventh Edition Research Unix at
 Bell Laboratories.
 AndroidLint, a part of the standard Android SDK.
\end_layout

\begin_layout Standard
What the tools does is examine your code, and offer opinions based on expert-lev
el knowledge of the language and libraries.
 But there will be cases where you're right.
 And, of course, it's an impossibly-hard problem for the computer to know
 which, so there is no substitute for the judgement of an experienced developer!
\end_layout

\begin_layout Standard
One very common error is to create a Toast by calling makeText(), and forget
 to call the new Toast's show() method; the toast is created but never pops
 up! The standard compiler cannot catch this kind of error, but Android
 Lint can, and that is just one of its many capabilities.
 you can run it under Eclipse.
 
\end_layout

\begin_layout Subsection
Unit teszt
\end_layout

\begin_layout Standard
Az Android tesztek JUnit-on alapszanak.
 Hagyományos JUnit teszteket is használtam a unit tesztek írásakor, ezek
 anem használják az Android API-t.
 Az Android teszt esetekkel az Android komponensek megfelelő viselkedését
 tesztelem ezek a teszt osztályok az AndroidTestCase-ből öröklődnek, melyek
 a JUnit keretrendszeren túl Android specifikus setup, teardown, és egyéb
 segád metódusokat tartalmaznak.
 A JUnit-beli Assert osztályt használva jeleníthetjük meg a teszt eredményeket.
 Ezek a metódusok összehasonlítják kapott eredménzeket a tesztben várt eredménze
kkel és ha nem egyeznek meg akkor hivételt generálnak, mely esetben a teszt
 eset hibát fog jelezni.
\end_layout

\begin_layout Standard
Külön teszt projektet készítettem a DriveTest applikáció teszteléséhez 
\shape italic
DriveTestingTest 
\shape default
néven.
 
\end_layout

\begin_layout Standard

\series bold
Instrumentation
\end_layout

\begin_layout Standard
Android instrumentation is a set of control methods or "hooks" in the Android
 system.
 These hooks control an Android component independently of its normal lifecycle.
 They also control how Android loads applications.Normally, an Android component
 runs in a lifecycle determined by the system.
 For example, an Activity object's lifecycle starts when the Activity is
 activated by an Intent.
 The object's onCreate() method is called, followed by onResume().
 When the user starts another application, the onPause() method is called.
 If the Activity code calls the finish() method, the onDestroy() method
 is called.
 The Android framework API does not provide a way for your code to invoke
 these callback methods directly, but you can do so using instrumentation.
\end_layout

\begin_layout Standard
You use the 
\series bold
ApplicationTestCase 
\series default
test case class to test the setup and teardown of Application objects.
 These objects maintain the global state of information that applies to
 all the components in an application package.
 The test case can be useful in verifying that the <application> element
 in the manifest file is correctly set up.
 Note, however, that this test case does not allow you to control testing
 of the components within your application package.
\end_layout

\begin_layout Subsection
Rendszer teszt
\end_layout

\begin_layout Standard
program tesztelése valódi mobilon és emulátoron.
 (blackbox)
\end_layout

\begin_layout Subsection
Tesztelés eredménye
\end_layout

\begin_layout Standard
tesztelések eredményének összefoglalása, a tesztelés alatt előforduló hibák
 megjegyzése és a javítás dokumentálása
\end_layout

\begin_layout Standard
esetleg hatékonyság elemzés, 
\end_layout

\begin_layout Section
Továbbfejlesztési lehetőségek
\end_layout

\begin_layout Standard
limitációk, ToDo-k, tervezett módosítások összegzése.
\end_layout

\begin_layout Chapter
Összefoglalás
\end_layout

\begin_layout Chapter
\start_of_appendix
Használt eszközök a fejlesztés során
\end_layout

\begin_layout Standard
Irodalomjegyzék
\end_layout

\begin_layout Standard
http://www.jmarshall.com/easy/http/
\end_layout

\begin_layout Standard
http://www.rfc-editor.org/rfc/rfc1945.txt
\end_layout

\begin_layout Standard
http://en.wikipedia.org/wiki/Mobile_phone_signal
\end_layout

\begin_layout Standard
http://en.wikipedia.org/wiki/DBm
\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"

\end_inset


\end_layout

\end_body
\end_document
